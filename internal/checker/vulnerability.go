package checker

import (
	"fmt"
	"strings"
)

// Vulnerability represents a security finding with detailed information
type Vulnerability struct {
	Name            string   `json:"name"`
	Category        string   `json:"category"`
	Severity        string   `json:"severity"`        // Critical, High, Medium, Low, Info
	Score           int      `json:"score"`           // Current score (0 for failures)
	MaxScore        int      `json:"max_score"`       // Maximum possible score
	Status          string   `json:"status"`          // Passed, Failed, Warning
	Description     string   `json:"description"`     // Detailed explanation
	Recommendation  string   `json:"recommendation"`  // How to fix
	CVSS            *CVSSScore `json:"cvss,omitempty"` // CVSS scoring
	AffectedURLs    []string `json:"affected_urls"`   // URLs where this was detected
	References      []string `json:"references,omitempty"` // External references
	CodeExample     string   `json:"code_example,omitempty"` // Example fix code
	TestingStrategy string   `json:"testing_strategy,omitempty"` // How to test
}

// CVSSScore represents CVSS scoring information
type CVSSScore struct {
	BaseScore  float64 `json:"base_score"`
	Vector     string  `json:"vector"`
	Severity   string  `json:"severity"`
	Version    string  `json:"version"` // "3.1" or "4.0"
}

// VulnerabilityReport contains all security findings
type VulnerabilityReport struct {
	ScanDate        string          `json:"scan_date"`
	Duration        string          `json:"duration"`
	ScanURL         string          `json:"scan_url"`
	Status          string          `json:"status"`
	TotalURLsScanned int            `json:"total_urls_scanned"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
	Summary         VulnerabilitySummary `json:"summary"`
}

// VulnerabilitySummary provides count by severity
type VulnerabilitySummary struct {
	Critical int `json:"critical"`
	High     int `json:"high"`
	Medium   int `json:"medium"`
	Low      int `json:"low"`
	Info     int `json:"info"`
	Total    int `json:"total"`
}

// BuildVulnerabilityReport analyzes CheckResults and generates vulnerability findings
func BuildVulnerabilityReport(results []CheckResult, scanURL string, startTime, endTime string) *VulnerabilityReport {
	report := &VulnerabilityReport{
		ScanDate:        startTime,
		Duration:        endTime,
		ScanURL:         scanURL,
		Status:          "Completed",
		TotalURLsScanned: len(results),
		Vulnerabilities: []Vulnerability{},
		Summary:         VulnerabilitySummary{},
	}

	// Aggregate findings across all targets
	findingDetails := make(map[string]*Vulnerability)

	for _, result := range results {
		// Analyze security headers
		if result.SecurityHeaders != nil {
			vulns := analyzeSecurityHeaders(result.SecurityHeaders, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze TLS compliance
		if result.TLSCompliance != nil {
			vulns := analyzeTLSCompliance(result.TLSCompliance, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze cookies
		if len(result.CookieFindings) > 0 {
			vulns := analyzeCookieFindings(result.CookieFindings, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze CORS
		if result.CORSInsights != nil && len(result.CORSInsights.Issues) > 0 {
			vulns := analyzeCORSIssues(result.CORSInsights, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze cache policy
		if result.CachePolicy != nil && len(result.CachePolicy.Issues) > 0 {
			vulns := analyzeCachePolicy(result.CachePolicy, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}
	}

	// Convert map to slice and calculate summary
	for _, vuln := range findingDetails {
		report.Vulnerabilities = append(report.Vulnerabilities, *vuln)
		switch vuln.Severity {
		case "Critical":
			report.Summary.Critical++
		case "High":
			report.Summary.High++
		case "Medium":
			report.Summary.Medium++
		case "Low":
			report.Summary.Low++
		case "Info":
			report.Summary.Info++
		}
		report.Summary.Total++
	}

	// Sort vulnerabilities by severity (Critical > High > Medium > Low > Info)
	sortVulnerabilitiesBySeverity(report.Vulnerabilities)

	return report
}

// sortVulnerabilitiesBySeverity sorts vulnerabilities by severity in descending order
func sortVulnerabilitiesBySeverity(vulns []Vulnerability) {
	severityOrder := map[string]int{
		"Critical": 5,
		"High":     4,
		"Medium":   3,
		"Low":      2,
		"Info":     1,
	}

	// Simple bubble sort (sufficient for small lists)
	for i := 0; i < len(vulns); i++ {
		for j := i + 1; j < len(vulns); j++ {
			if severityOrder[vulns[i].Severity] < severityOrder[vulns[j].Severity] {
				vulns[i], vulns[j] = vulns[j], vulns[i]
			}
		}
	}
}

// analyzeSecurityHeaders converts security header findings into vulnerabilities
func analyzeSecurityHeaders(sh *SecurityHeadersResult, target string) []Vulnerability {
	vulns := []Vulnerability{}

	// Check for missing CSP
	if header, ok := sh.Headers["Content-Security-Policy"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "Content Security Policy (CSP)",
			Category: "Content Security Policy (CSP)",
			Severity: "Critical",
			Score:    0,
			MaxScore: 20,
			Status:   "Failed",
			Description: "CSP (Content Security Policy) is a security standard that helps websites defend against attacks such as Cross-Site Scripting (XSS) and data injection attacks. It does this by defining trusted sources for content loading and execution. By preventing unauthorized script execution and resource loading from malicious origins, CSP significantly enhances website security, safeguards user data, and maintains the integrity of web applications. It's a crucial component of a robust web security policy.",
			Recommendation: `CRITICAL: Content Security Policy header missing. Your website is vulnerable to XSS and injection attacks without Content Security Policy protection, allowing attackers to inject malicious scripts and steal user data.

Immediate Action Required:

1. Implement a basic CSP (Content Security Policy) header to protect against XSS attacks
2. Start with a restrictive policy and gradually allow necessary sources
3. Test thoroughly before enforcing the policy

Implementation by Platform:

• Apache: Add to .htaccess or server config
• Nginx: Add to server block
• Express.js: Use helmet middleware
• WordPress: Use security plugins
• Cloudflare: Enable in Security settings

Basic CSP Example:

Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';

Testing Strategy:

1. Start with Report-Only: Content-Security-Policy-Report-Only
2. Monitor violations in browser console and server logs
3. Gradually tighten the policy based on actual usage
4. Switch to enforced mode once stable`,
			CVSS: &CVSSScore{
				BaseScore: 9.1,
				Severity:  "CRITICAL",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
			References: []string{
				"https://owasp.org/www-project-secure-headers/",
				"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP",
				"https://content-security-policy.com/",
			},
			CodeExample: `Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';`,
			TestingStrategy: `1. Start with Report-Only: Content-Security-Policy-Report-Only
2. Monitor violations in browser console and server logs
3. Gradually tighten the policy based on actual usage
4. Switch to enforced mode once stable`,
		})
	}

	// Check for missing HSTS
	if header, ok := sh.Headers["Strict-Transport-Security"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "HTTP Strict Transport Security (HSTS)",
			Category: "Security Headers",
			Severity: "High",
			Score:    0,
			MaxScore: 20,
			Status:   "Failed",
			Description: "HSTS (HTTP Strict Transport Security) forces browsers to only connect to your website over HTTPS, preventing man-in-the-middle attacks and protocol downgrade attacks. Without HSTS, attackers can intercept the first HTTP request before the redirect to HTTPS.",
			Recommendation: `HIGH: Strict-Transport-Security header missing. Your website is vulnerable to man-in-the-middle attacks and protocol downgrade attacks.

Immediate Action Required:

1. Implement HSTS header on all HTTPS responses
2. Start with a short max-age and gradually increase
3. Add includeSubDomains for all subdomains
4. Consider HSTS preloading for maximum protection

Recommended HSTS Header:

Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

Implementation:
• Apache: Header always set Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
• Nginx: add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
• Express.js: app.use(helmet.hsts({maxAge: 31536000, includeSubDomains: true, preload: true}))`,
			CVSS: &CVSSScore{
				BaseScore: 7.4,
				Severity:  "HIGH",
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for missing X-Frame-Options
	if header, ok := sh.Headers["X-Frame-Options"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "X-Frame-Options",
			Category: "Security Headers",
			Severity: "High",
			Score:    0,
			MaxScore: 15,
			Status:   "Failed",
			Description: "X-Frame-Options prevents your website from being embedded in frames or iframes, protecting against clickjacking attacks where attackers trick users into clicking hidden elements.",
			Recommendation: `HIGH: X-Frame-Options header missing. Your website is vulnerable to clickjacking attacks.

Recommended Header:

X-Frame-Options: DENY

Or if you need to allow framing from same origin:

X-Frame-Options: SAMEORIGIN

Modern alternative (use both for maximum compatibility):

Content-Security-Policy: frame-ancestors 'none';

Implementation:
• Apache: Header always set X-Frame-Options "DENY"
• Nginx: add_header X-Frame-Options "DENY" always;
• Express.js: app.use(helmet.frameguard({ action: 'deny' }))`,
			CVSS: &CVSSScore{
				BaseScore: 5.3,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for missing X-Content-Type-Options
	if header, ok := sh.Headers["X-Content-Type-Options"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "X-Content-Type-Options",
			Category: "Security Headers",
			Severity: "High",
			Score:    0,
			MaxScore: 15,
			Status:   "Failed",
			Description: "X-Content-Type-Options prevents browsers from MIME-sniffing responses away from the declared content-type. This reduces exposure to drive-by download attacks and cross-site scripting attacks.",
			Recommendation: `HIGH: X-Content-Type-Options header missing. Your website is vulnerable to MIME-sniffing attacks.

Recommended Header:

X-Content-Type-Options: nosniff

This header prevents browsers from trying to MIME-sniff the content type and forces them to stick with the declared content-type.

Implementation:
• Apache: Header always set X-Content-Type-Options "nosniff"
• Nginx: add_header X-Content-Type-Options "nosniff" always;
• Express.js: app.use(helmet.noSniff())
• PHP: header('X-Content-Type-Options: nosniff');`,
			CVSS: &CVSSScore{
				BaseScore: 6.1,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for missing Referrer-Policy
	if header, ok := sh.Headers["Referrer-Policy"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "Referrer-Policy",
			Category: "Security Headers",
			Severity: "Medium",
			Score:    0,
			MaxScore: 10,
			Status:   "Failed",
			Description: "Referrer-Policy controls how much referrer information (sent via the Referer header) should be included with requests. Without this header, sensitive information in URLs may be leaked to third parties.",
			Recommendation: `MEDIUM: Referrer-Policy header missing. Sensitive URL information may be leaked to third parties.

Recommended Headers:

Referrer-Policy: strict-origin-when-cross-origin

Or for maximum privacy:

Referrer-Policy: no-referrer

Options explained:
• no-referrer: Never send referrer information
• strict-origin-when-cross-origin: Send full URL for same-origin, only origin for cross-origin
• same-origin: Only send referrer for same-origin requests

Implementation:
• Apache: Header always set Referrer-Policy "strict-origin-when-cross-origin"
• Nginx: add_header Referrer-Policy "strict-origin-when-cross-origin" always;
• Express.js: app.use(helmet.referrerPolicy({ policy: 'strict-origin-when-cross-origin' }))`,
			CVSS: &CVSSScore{
				BaseScore: 3.7,
				Severity:  "LOW",
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for missing Permissions-Policy
	if header, ok := sh.Headers["Permissions-Policy"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "Permissions-Policy",
			Category: "Security Headers",
			Severity: "Medium",
			Score:    0,
			MaxScore: 10,
			Status:   "Failed",
			Description: "Permissions-Policy (formerly Feature-Policy) allows you to control which browser features and APIs can be used in the browser, preventing misuse of powerful features like geolocation, camera, microphone, etc.",
			Recommendation: `MEDIUM: Permissions-Policy header missing. Browser features are not restricted.

Recommended Header:

Permissions-Policy: geolocation=(), microphone=(), camera=(), payment=(), usb=(), magnetometer=(), gyroscope=(), accelerometer=()

This disables potentially dangerous browser features. Adjust based on your needs.

Implementation:
• Apache: Header always set Permissions-Policy "geolocation=(), microphone=(), camera=()"
• Nginx: add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
• Express.js: app.use(helmet.permissionsPolicy())`,
			CVSS: &CVSSScore{
				BaseScore: 4.3,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for HSTS with issues (present but not perfect)
	if header, ok := sh.Headers["Strict-Transport-Security"]; ok && header.Present && len(header.Issues) > 0 {
		vulns = append(vulns, Vulnerability{
			Name:     "HSTS Configuration Issue",
			Category: "Security Headers",
			Severity: "Low",
			Score:    header.Score,
			MaxScore: header.MaxScore,
			Status:   "Warning",
			Description: "HTTP Strict Transport Security (HSTS) is present but has configuration issues that reduce its effectiveness.",
			Recommendation: fmt.Sprintf(`LOW: HSTS header has configuration issues.

Current value: %s

Issues found:
%s

Recommended Header:

Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

The 'preload' directive allows your site to be included in browsers' HSTS preload list for maximum protection.`,
				header.Value,
				strings.Join(header.Issues, "\n")),
			CVSS: &CVSSScore{
				BaseScore: 3.7,
				Severity:  "LOW",
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for missing Cross-Origin-Embedder-Policy
	if header, ok := sh.Headers["Cross-Origin-Embedder-Policy"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "Cross-Origin-Embedder-Policy (COEP)",
			Category: "Security Headers",
			Severity: "Medium",
			Score:    0,
			MaxScore: 5,
			Status:   "Failed",
			Description: "Cross-Origin-Embedder-Policy (COEP) prevents a document from loading any cross-origin resources that don't explicitly grant permission. This helps protect against side-channel attacks like Spectre.",
			Recommendation: `MEDIUM: Cross-Origin-Embedder-Policy header missing.

Recommended Header:

Cross-Origin-Embedder-Policy: require-corp

This ensures that all resources loaded by the document have opted in to being loaded cross-origin.

Implementation:
• Apache: Header always set Cross-Origin-Embedder-Policy "require-corp"
• Nginx: add_header Cross-Origin-Embedder-Policy "require-corp" always;
• Express.js: app.use((req, res, next) => { res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp'); next(); })

Note: This may require updating CORS headers on your resources.`,
			CVSS: &CVSSScore{
				BaseScore: 4.3,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for missing Cross-Origin-Opener-Policy
	if header, ok := sh.Headers["Cross-Origin-Opener-Policy"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "Cross-Origin-Opener-Policy (COOP)",
			Category: "Security Headers",
			Severity: "Medium",
			Score:    0,
			MaxScore: 5,
			Status:   "Failed",
			Description: "Cross-Origin-Opener-Policy (COOP) allows you to ensure that a top-level document does not share a browsing context group with cross-origin documents. This helps protect against cross-origin attacks like XS-Leaks.",
			Recommendation: `MEDIUM: Cross-Origin-Opener-Policy header missing.

Recommended Header:

Cross-Origin-Opener-Policy: same-origin

This isolates your browsing context to prevent cross-origin attacks.

Options:
• same-origin: Isolates the browsing context exclusively to same-origin documents
• same-origin-allow-popups: Allows the document to retain references to popups
• unsafe-none: Default, allows sharing browsing context (not recommended)

Implementation:
• Apache: Header always set Cross-Origin-Opener-Policy "same-origin"
• Nginx: add_header Cross-Origin-Opener-Policy "same-origin" always;
• Express.js: app.use((req, res, next) => { res.setHeader('Cross-Origin-Opener-Policy', 'same-origin'); next(); })`,
			CVSS: &CVSSScore{
				BaseScore: 4.3,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for server header exposure in warnings
	if len(sh.Warnings) > 0 {
		for _, warning := range sh.Warnings {
			if strings.Contains(warning, "Server header exposes") {
				vulns = append(vulns, Vulnerability{
					Name:     "Server Information Disclosure",
					Category: "Information Disclosure",
					Severity: "Low",
					Score:    0,
					MaxScore: 5,
					Status:   "Warning",
					Description: "The Server header exposes information about your web server software and version. This information can help attackers identify known vulnerabilities in specific server versions and target attacks more effectively.",
					Recommendation: `LOW: Server header exposes server software information.

Current issue: ` + warning + `

Recommended Actions:

1. Remove the Server header entirely (most secure)
2. Or obfuscate it to a generic value

Implementation:
• Nginx: Add to nginx.conf:
  server_tokens off;
  more_clear_headers 'Server';

• Apache: Add to httpd.conf:
  ServerTokens Prod
  ServerSignature Off
  Header unset Server

• Express.js:
  app.disable('x-powered-by');
  app.use((req, res, next) => { res.removeHeader('Server'); next(); })

Removing server information makes it harder for attackers to identify your stack and find specific exploits.`,
					CVSS: &CVSSScore{
						BaseScore: 2.0,
						Severity:  "LOW",
						Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
						Version:   "3.1",
					},
				})
			}
		}
	}

	// Add passed checks (properly configured headers)
	if header, ok := sh.Headers["X-Frame-Options"]; ok && header.Present {
		vulns = append(vulns, Vulnerability{
			Name:     "X-Frame-Options",
			Category: "Security Headers",
			Severity: "Info",
			Score:    header.Score,
			MaxScore: header.MaxScore,
			Status:   "Passed",
			Description: "X-Frame-Options is properly configured to prevent clickjacking attacks.",
			Recommendation: fmt.Sprintf(`PASSED: X-Frame-Options is properly configured.

Current value: %s

This header prevents your website from being embedded in frames or iframes, protecting against clickjacking attacks.

Your configuration is secure. No action required.`, header.Value),
		})
	}

	if header, ok := sh.Headers["Strict-Transport-Security"]; ok && header.Present && len(header.Issues) == 0 {
		vulns = append(vulns, Vulnerability{
			Name:     "HTTP Strict Transport Security (HSTS)",
			Category: "Security Headers",
			Severity: "Info",
			Score:    header.Score,
			MaxScore: header.MaxScore,
			Status:   "Passed",
			Description: "HSTS is properly configured to enforce HTTPS connections.",
			Recommendation: fmt.Sprintf(`PASSED: HSTS is properly configured.

Current value: %s

This header forces browsers to only connect via HTTPS, preventing man-in-the-middle attacks.

Your configuration is secure. No action required.`, header.Value),
		})
	}

	return vulns
}

// analyzeTLSCompliance converts TLS findings into vulnerabilities
func analyzeTLSCompliance(tls *TLSComplianceResult, target string) []Vulnerability {
	vulns := []Vulnerability{}

	// Critical issues
	for _, issue := range tls.Issues {
		severity := "Medium"
		cvssScore := 5.3
		if issue.Severity == "critical" {
			severity = "Critical"
			cvssScore = 9.1
		} else if issue.Severity == "high" {
			severity = "High"
			cvssScore = 7.4
		}

		vulns = append(vulns, Vulnerability{
			Name:           issue.Standard + ": " + issue.Requirement,
			Category:       "TLS/SSL Configuration",
			Severity:       severity,
			Score:          0,
			MaxScore:       20,
			Status:         "Failed",
			Description:    issue.Description,
			Recommendation: issue.Remediation,
			CVSS: &CVSSScore{
				BaseScore: cvssScore,
				Severity:  strings.ToUpper(severity),
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
		})
	}

	// Recommendations (not critical but good practice)
	for _, rec := range tls.Recommendations {
		if strings.Contains(rec, "TLS 1.3") {
			vulns = append(vulns, Vulnerability{
				Name:     "TLS Version Recommendation",
				Category: "TLS/SSL Configuration",
				Severity: "Info",
				Score:    0,
				MaxScore: 5,
				Status:   "Info",
				Description: "Your site is using TLS 1.2, which is secure but not the latest version. TLS 1.3 offers improved security and performance benefits.",
				Recommendation: fmt.Sprintf(`INFO: %s

TLS 1.3 Benefits:
• Improved security with removed outdated cipher suites
• Faster handshake (1-RTT instead of 2-RTT)
• Better privacy (encrypted handshake)
• Mandatory forward secrecy

Implementation:
• Nginx: ssl_protocols TLSv1.2 TLSv1.3;
• Apache: SSLProtocol -all +TLSv1.2 +TLSv1.3
• Most modern servers support TLS 1.3 by default

Note: Ensure client compatibility before disabling TLS 1.2`, rec),
			})
		}

		if strings.Contains(rec, "Certificate expires") {
			vulns = append(vulns, Vulnerability{
				Name:     "TLS Certificate Expiring Soon",
				Category: "TLS/SSL Configuration",
				Severity: "Medium",
				Score:    0,
				MaxScore: 5,
				Status:   "Warning",
				Description: "Your TLS certificate is approaching expiration. Expired certificates cause browser warnings and connection failures, disrupting service availability.",
				Recommendation: fmt.Sprintf(`MEDIUM: %s

Actions Required:

1. Renew your certificate before expiration
2. Set up automated renewal (e.g., with certbot for Let's Encrypt)
3. Monitor certificate expiration dates

For Let's Encrypt certificates:
• Use certbot with auto-renewal: certbot renew --dry-run
• Set up cron job: 0 0 * * * certbot renew --quiet

For other CAs:
• Check your certificate management dashboard
• Set up renewal reminders
• Consider automated certificate management tools`, rec),
				CVSS: &CVSSScore{
					BaseScore: 5.3,
					Severity:  "MEDIUM",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
					Version:   "3.1",
				},
			})
		}
	}

	return vulns
}

// analyzeCookieFindings converts cookie findings into vulnerabilities
func analyzeCookieFindings(cookies []CookieFinding, target string) []Vulnerability {
	vulns := []Vulnerability{}

	hasInsecureCookies := false
	for _, cookie := range cookies {
		if cookie.MissingSecure || cookie.MissingHTTPOnly {
			hasInsecureCookies = true
			break
		}
	}

	if hasInsecureCookies {
		vulns = append(vulns, Vulnerability{
			Name:     "Insecure Cookie Configuration",
			Category: "Session Management",
			Severity: "Medium",
			Score:    0,
			MaxScore: 15,
			Status:   "Failed",
			Description: "Cookies are missing Secure and/or HttpOnly flags. Cookies without the Secure flag can be transmitted over unencrypted HTTP connections, allowing attackers to intercept them. Cookies without HttpOnly can be accessed by JavaScript, making them vulnerable to XSS attacks and session hijacking.",
			Recommendation: `MEDIUM: Insecure cookie configuration detected.

Required Flags:
• Secure flag: Ensures cookies are only sent over HTTPS
• HttpOnly flag: Prevents JavaScript access to cookies

Implementation:
• PHP: session_set_cookie_params(['secure' => true, 'httponly' => true, 'samesite' => 'Strict']);
• Express.js: res.cookie('name', 'value', { secure: true, httpOnly: true, sameSite: 'strict' });
• Java: cookie.setSecure(true); cookie.setHttpOnly(true);

All session cookies should have both Secure and HttpOnly flags set.`,
			CVSS: &CVSSScore{
				BaseScore: 5.9,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
				Version:   "3.1",
			},
		})
	}

	return vulns
}

// analyzeCORSIssues converts CORS findings into vulnerabilities
func analyzeCORSIssues(cors *CORSReport, target string) []Vulnerability {
	vulns := []Vulnerability{}

	if cors.AllowsAnyOrigin && cors.AllowCredentials {
		vulns = append(vulns, Vulnerability{
			Name:     "Overly Permissive CORS Policy",
			Category: "CORS Configuration",
			Severity: "High",
			Score:    0,
			MaxScore: 20,
			Status:   "Failed",
			Description: "The CORS policy allows any origin (*) with credentials enabled. This is a dangerous configuration that allows any website to make authenticated requests to your API, potentially exposing sensitive user data and enabling cross-site request forgery attacks.",
			Recommendation: `HIGH: Dangerous CORS configuration detected.

Issues:
• Access-Control-Allow-Origin: * with credentials enabled
• This allows any website to access your API with user credentials

Fix:
1. Never use Access-Control-Allow-Origin: * with credentials
2. Specify exact allowed origins: Access-Control-Allow-Origin: https://trusted-domain.com
3. Validate and whitelist origins on the server side
4. Only enable credentials when absolutely necessary

Example (Express.js):
const allowedOrigins = ['https://trusted-domain.com'];
app.use(cors({
  origin: function (origin, callback) {
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));`,
			CVSS: &CVSSScore{
				BaseScore: 8.1,
				Severity:  "HIGH",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
		})
	}

	return vulns
}

// analyzeCachePolicy converts cache policy findings into vulnerabilities
func analyzeCachePolicy(cache *CachePolicy, target string) []Vulnerability {
	vulns := []Vulnerability{}

	for _, issue := range cache.Issues {
		if strings.Contains(issue, "Expires header missing") {
			vulns = append(vulns, Vulnerability{
				Name:     "Missing Cache Expires Header",
				Category: "Cache Configuration",
				Severity: "Low",
				Score:    0,
				MaxScore: 5,
				Status:   "Info",
				Description: "The Expires header is missing. While Cache-Control is present, having both headers provides better compatibility with older browsers and proxies.",
				Recommendation: fmt.Sprintf(`LOW: %s

Current cache configuration:
Cache-Control: %s

Recommendation:

Add an Expires header for better compatibility:
Expires: <HTTP-date>

Example Configuration:

For static assets (1 year):
• Nginx:
  expires 1y;
  add_header Cache-Control "public, immutable";

• Apache:
  ExpiresActive On
  ExpiresDefault "access plus 1 year"

For dynamic content (no cache):
• Nginx:
  expires -1;
  add_header Cache-Control "no-cache, no-store, must-revalidate";

• Apache:
  ExpiresActive On
  ExpiresDefault "access plus 0 seconds"

Note: Modern browsers primarily use Cache-Control, but Expires provides backward compatibility.`,
					issue, cache.CacheControl),
				CVSS: &CVSSScore{
					BaseScore: 0.0,
					Severity:  "NONE",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N",
					Version:   "3.1",
				},
			})
		}
	}

	return vulns
}
