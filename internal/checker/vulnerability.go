package checker

import (
	"fmt"
	"sort"
	"strings"
)

// Vulnerability represents a security finding with detailed information
type Vulnerability struct {
	Name              string                       `json:"name"`
	Category          string                       `json:"category"`
	Severity          string                       `json:"severity"`                   // Critical, High, Medium, Low, Info
	Score             int                          `json:"score"`                      // Current score (0 for failures)
	MaxScore          int                          `json:"max_score"`                  // Maximum possible score
	Status            string                       `json:"status"`                     // Passed, Failed, Warning
	Description       string                       `json:"description"`                // Detailed explanation
	Recommendation    string                       `json:"recommendation"`             // How to fix
	CVSS              *CVSSScore                   `json:"cvss,omitempty"`             // CVSS scoring
	AffectedURLs      []string                     `json:"affected_urls"`              // URLs where this was detected
	References        []string                     `json:"references,omitempty"`       // External references
	CodeExample       string                       `json:"code_example,omitempty"`     // Example fix code
	TestingStrategy   string                       `json:"testing_strategy,omitempty"` // How to test
	ComplianceMapping map[string]ComplianceDetails `json:"compliance_mapping,omitempty"` // Framework ID -> Compliance details
}

// ComplianceDetails holds compliance-specific information for a security check
type ComplianceDetails struct {
	Requirements []string `json:"requirements"`        // Requirement IDs (e.g., ["A.8.24", "A.8.9"])
	Priority     string   `json:"priority,omitempty"`  // Priority within this framework
	Notes        string   `json:"notes,omitempty"`     // Additional framework-specific notes
}

// CVSSScore represents CVSS scoring information
type CVSSScore struct {
	BaseScore float64 `json:"base_score"`
	Vector    string  `json:"vector"`
	Severity  string  `json:"severity"`
	Version   string  `json:"version"` // "3.1" or "4.0"
}

// VulnerabilityReport contains all security findings
type VulnerabilityReport struct {
	ScanDate         string               `json:"scan_date"`
	Duration         string               `json:"duration"`
	ScanURL          string               `json:"scan_url"`
	Status           string               `json:"status"`
	TotalURLsScanned int                  `json:"total_urls_scanned"`
	Vulnerabilities  []Vulnerability      `json:"vulnerabilities"`
	Summary          VulnerabilitySummary `json:"summary"`
	ResultSources    []string             `json:"result_sources,omitempty"`
}

// VulnerabilitySummary provides count by severity
type VulnerabilitySummary struct {
	Critical int `json:"critical"`
	High     int `json:"high"`
	Medium   int `json:"medium"`
	Low      int `json:"low"`
	Info     int `json:"info"`
	Total    int `json:"total"`
}

// BuildVulnerabilityReport analyzes CheckResults and generates vulnerability findings
func BuildVulnerabilityReport(results []CheckResult, scanURL string, startTime, endTime string) *VulnerabilityReport {
	report := &VulnerabilityReport{
		ScanDate:         startTime,
		Duration:         endTime,
		ScanURL:          scanURL,
		Status:           "Completed",
		TotalURLsScanned: len(results),
		Vulnerabilities:  []Vulnerability{},
		Summary:          VulnerabilitySummary{},
	}

	// Aggregate findings across all targets
	findingDetails := make(map[string]*Vulnerability)

	for _, result := range results {
		// Analyze security headers
		if result.SecurityHeaders != nil {
			vulns := analyzeSecurityHeaders(result.SecurityHeaders, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze TLS compliance
		if result.TLSCompliance != nil {
			vulns := analyzeTLSCompliance(result.TLSCompliance, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze cookies
		if len(result.CookieFindings) > 0 {
			vulns := analyzeCookieFindings(result.CookieFindings, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze CORS
		if result.CORSInsights != nil && len(result.CORSInsights.Issues) > 0 {
			vulns := analyzeCORSIssues(result.CORSInsights, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze cache policy
		if result.CachePolicy != nil && len(result.CachePolicy.Issues) > 0 {
			vulns := analyzeCachePolicy(result.CachePolicy, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze client-side security (vulnerable libraries, CSRF, Trusted Types)
		if result.ClientSecurity != nil {
			vulns := analyzeClientSecurity(result.ClientSecurity, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}

		// Analyze network security (open ports, subdomain takeover)
		if result.NetworkSecurity != nil {
			vulns := analyzeNetworkSecurity(result.NetworkSecurity, result.Target)
			for _, vuln := range vulns {
				key := vuln.Name
				if existing, ok := findingDetails[key]; ok {
					existing.AffectedURLs = append(existing.AffectedURLs, result.Target)
				} else {
					vuln.AffectedURLs = []string{result.Target}
					findingDetails[key] = &vuln
				}
			}
		}
	}

	// Convert map to slice and calculate summary
	for _, vuln := range findingDetails {
		report.Vulnerabilities = append(report.Vulnerabilities, *vuln)
		switch vuln.Severity {
		case "Critical":
			report.Summary.Critical++
		case "High":
			report.Summary.High++
		case "Medium":
			report.Summary.Medium++
		case "Low":
			report.Summary.Low++
		case "Info":
			report.Summary.Info++
		}
		report.Summary.Total++
	}

	// Sort vulnerabilities by severity (Critical > High > Medium > Low > Info)
	sortVulnerabilitiesBySeverity(report.Vulnerabilities)

	return report
}

// sortVulnerabilitiesBySeverity sorts vulnerabilities by severity in descending order
func sortVulnerabilitiesBySeverity(vulns []Vulnerability) {
	severityOrder := map[string]int{
		"Critical": 0,
		"High":     1,
		"Medium":   2,
		"Low":      3,
		"Info":     4,
	}

	sort.Slice(vulns, func(i, j int) bool {
		orderI := severityOrder[vulns[i].Severity]
		orderJ := severityOrder[vulns[j].Severity]
		// Sort by severity first
		if orderI != orderJ {
			return orderI < orderJ
		}
		// If severity is the same, sort by name alphabetically
		return vulns[i].Name < vulns[j].Name
	})
}

// EnrichWithComplianceData adds compliance mapping information to vulnerabilities
// This function should be called with a compliance mapping provider (e.g., from internal/compliance package)
func EnrichWithComplianceData(vulns []Vulnerability, mappingsProvider func(string) map[string][]string, priorityProvider func(string) map[string]string) []Vulnerability {
	enriched := make([]Vulnerability, len(vulns))
	copy(enriched, vulns)

	for i := range enriched {
		checkName := enriched[i].Name

		// Get compliance mappings for this check
		if mappingsProvider != nil {
			frameworks := mappingsProvider(checkName)
			if len(frameworks) > 0 {
				enriched[i].ComplianceMapping = make(map[string]ComplianceDetails)

				for frameworkID, requirements := range frameworks {
					details := ComplianceDetails{
						Requirements: requirements,
					}

					// Add priority if available
					if priorityProvider != nil {
						priorities := priorityProvider(checkName)
						if priority, ok := priorities[frameworkID]; ok {
							details.Priority = priority
						}
					}

					enriched[i].ComplianceMapping[frameworkID] = details
				}
			}
		}
	}

	return enriched
}

// FilterByCompliance filters vulnerabilities to only those relevant to a specific compliance framework
func FilterByCompliance(vulns []Vulnerability, frameworkID string) []Vulnerability {
	var filtered []Vulnerability

	for _, vuln := range vulns {
		if vuln.ComplianceMapping != nil {
			if _, ok := vuln.ComplianceMapping[frameworkID]; ok {
				filtered = append(filtered, vuln)
			}
		}
	}

	return filtered
}

// analyzeSecurityHeaders converts security header findings into vulnerabilities
func analyzeSecurityHeaders(sh *SecurityHeadersResult, target string) []Vulnerability {
	vulns := []Vulnerability{}

	// Check for CSP (always report - passed or failed)
	if header, ok := sh.Headers["Content-Security-Policy"]; ok {
		if !header.Present {
			vulns = append(vulns, Vulnerability{
				Name:        "Content Security Policy (CSP)",
				Category:    "Content Security Policy (CSP)",
				Severity:    "Critical",
				Score:       0,
				MaxScore:    20,
				Status:      "Failed",
				Description: "CSP (Content Security Policy) is a security standard that helps websites defend against attacks such as Cross-Site Scripting (XSS) and data injection attacks. It does this by defining trusted sources for content loading and execution. By preventing unauthorized script execution and resource loading from malicious origins, CSP significantly enhances website security, safeguards user data, and maintains the integrity of web applications. It's a crucial component of a robust web security policy.",
				Recommendation: `CRITICAL: Content Security Policy header missing. Your website is vulnerable to XSS and injection attacks without Content Security Policy protection, allowing attackers to inject malicious scripts and steal user data.

Immediate Action Required:

1. Implement a basic CSP (Content Security Policy) header to protect against XSS attacks
2. Start with a restrictive policy and gradually allow necessary sources
3. Test thoroughly before enforcing the policy

Implementation by Platform:

• Apache: Add to .htaccess or server config
• Nginx: Add to server block
• Express.js: Use helmet middleware
• WordPress: Use security plugins
• Cloudflare: Enable in Security settings

Basic CSP Example:

Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';

Testing Strategy:

1. Start with Report-Only: Content-Security-Policy-Report-Only
2. Monitor violations in browser console and server logs
3. Gradually tighten the policy based on actual usage
4. Switch to enforced mode once stable`,
				CVSS: &CVSSScore{
					BaseScore: 9.1,
					Severity:  "CRITICAL",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
					Version:   "3.1",
				},
				References: []string{
					"https://owasp.org/www-project-secure-headers/",
					"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP",
					"https://content-security-policy.com/",
				},
				CodeExample: `Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';`,
				TestingStrategy: `1. Start with Report-Only: Content-Security-Policy-Report-Only
2. Monitor violations in browser console and server logs
3. Gradually tighten the policy based on actual usage
4. Switch to enforced mode once stable`,
			})
		} else if len(header.Issues) > 0 {
			// CSP present but has issues
			vulns = append(vulns, Vulnerability{
				Name:        "Content Security Policy (CSP) Configuration Issue",
				Category:    "Content Security Policy (CSP)",
				Severity:    "Medium",
				Score:       header.Score,
				MaxScore:    header.MaxScore,
				Status:      "Warning",
				Description: "Content Security Policy is present but has configuration issues that may reduce its effectiveness.",
				Recommendation: fmt.Sprintf(`MEDIUM: CSP header has configuration issues.

Current value: %s

Issues found:
%s

Review and strengthen your CSP configuration to ensure maximum protection against XSS attacks.`,
					header.Value,
					strings.Join(header.Issues, "\n")),
			})
		} else {
			// CSP properly configured
			vulns = append(vulns, Vulnerability{
				Name:        "Content Security Policy (CSP)",
				Category:    "Content Security Policy (CSP)",
				Severity:    "Info",
				Score:       header.Score,
				MaxScore:    header.MaxScore,
				Status:      "Passed",
				Description: "Content Security Policy is properly configured to protect against XSS and injection attacks.",
				Recommendation: fmt.Sprintf(`PASSED: Content Security Policy is properly configured.

Current value: %s

This header helps protect against XSS and data injection attacks by defining trusted content sources.

Your configuration is secure. No action required.`, header.Value),
			})
		}
	}

	// CSP Bypass check (add as info - would require deep analysis to detect actual bypasses)
	if header, ok := sh.Headers["Content-Security-Policy"]; ok && header.Present {
		vulns = append(vulns, Vulnerability{
			Name:        "Content Security Policy (CSP) Bypass",
			Category:    "Content Security Policy (CSP)",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Info",
			Description: "CSP bypass detection requires deep analysis of policy directives. Common bypasses include overly permissive directives, JSONP endpoints, and unsafe-inline usage.",
			Recommendation: `INFO: CSP Bypass Analysis

Your CSP policy should be reviewed for potential bypasses:

Common CSP Bypass Vectors:
• 'unsafe-inline' directive allows inline scripts
• 'unsafe-eval' permits eval() and similar functions
• Wildcard sources (*.example.com) may be too permissive
• JSONP endpoints can be exploited
• base-uri not set allows base tag injection
• object-src not restricted allows plugin injection

Review Checklist:
1. Avoid 'unsafe-inline' and 'unsafe-eval' if possible
2. Use nonces or hashes for inline scripts
3. Restrict script-src to specific domains
4. Set base-uri 'none' or 'self'
5. Set object-src 'none'
6. Use CSP Evaluator tool: https://csp-evaluator.withgoogle.com/

Current policy: ` + header.Value + `

Regular CSP auditing is recommended.`,
		})
	}

	// Check for missing HSTS
	if header, ok := sh.Headers["Strict-Transport-Security"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:        "HTTP Strict Transport Security (HSTS)",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "High",
			Score:       0,
			MaxScore:    20,
			Status:      "Failed",
			Description: "HSTS (HTTP Strict Transport Security) forces browsers to only connect to your website over HTTPS, preventing man-in-the-middle attacks and protocol downgrade attacks. Without HSTS, attackers can intercept the first HTTP request before the redirect to HTTPS.",
			Recommendation: `HIGH: Strict-Transport-Security header missing. Your website is vulnerable to man-in-the-middle attacks and protocol downgrade attacks.

Immediate Action Required:

1. Implement HSTS header on all HTTPS responses
2. Start with a short max-age and gradually increase
3. Add includeSubDomains for all subdomains
4. Consider HSTS preloading for maximum protection

Recommended HSTS Header:

Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

Implementation:
• Apache: Header always set Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
• Nginx: add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
• Express.js: app.use(helmet.hsts({maxAge: 31536000, includeSubDomains: true, preload: true}))`,
			CVSS: &CVSSScore{
				BaseScore: 7.4,
				Severity:  "HIGH",
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for missing X-Frame-Options
	if header, ok := sh.Headers["X-Frame-Options"]; ok && !header.Present {
		vulns = append(vulns, Vulnerability{
			Name:        "X-Frame-Options",
			Category:    "Clickjacking Protection",
			Severity:    "High",
			Score:       0,
			MaxScore:    15,
			Status:      "Failed",
			Description: "X-Frame-Options prevents your website from being embedded in frames or iframes, protecting against clickjacking attacks where attackers trick users into clicking hidden elements.",
			Recommendation: `HIGH: X-Frame-Options header missing. Your website is vulnerable to clickjacking attacks.

Recommended Header:

X-Frame-Options: DENY

Or if you need to allow framing from same origin:

X-Frame-Options: SAMEORIGIN

Modern alternative (use both for maximum compatibility):

Content-Security-Policy: frame-ancestors 'none';

Implementation:
• Apache: Header always set X-Frame-Options "DENY"
• Nginx: add_header X-Frame-Options "DENY" always;
• Express.js: app.use(helmet.frameguard({ action: 'deny' }))`,
			CVSS: &CVSSScore{
				BaseScore: 5.3,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for X-Content-Type-Options (always report)
	if header, ok := sh.Headers["X-Content-Type-Options"]; ok {
		if !header.Present {
			vulns = append(vulns, Vulnerability{
				Name:        "X-Content-Type-Options",
				Category:    "Cross-Site Scripting (XSS) Protection",
				Severity:    "High",
				Score:       0,
				MaxScore:    15,
				Status:      "Failed",
				Description: "X-Content-Type-Options prevents browsers from MIME-sniffing responses away from the declared content-type. This reduces exposure to drive-by download attacks and cross-site scripting attacks.",
				Recommendation: `HIGH: X-Content-Type-Options header missing. Your website is vulnerable to MIME-sniffing attacks.

Recommended Header:

X-Content-Type-Options: nosniff

This header prevents browsers from trying to MIME-sniff the content type and forces them to stick with the declared content-type.

Implementation:
• Apache: Header always set X-Content-Type-Options "nosniff"
• Nginx: add_header X-Content-Type-Options "nosniff" always;
• Express.js: app.use(helmet.noSniff())
• PHP: header('X-Content-Type-Options: nosniff');`,
				CVSS: &CVSSScore{
					BaseScore: 6.1,
					Severity:  "MEDIUM",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
					Version:   "3.1",
				},
			})
		} else {
			// X-Content-Type-Options properly configured
			vulns = append(vulns, Vulnerability{
				Name:        "X-Content-Type-Options",
				Category:    "Cross-Site Scripting (XSS) Protection",
				Severity:    "Info",
				Score:       header.Score,
				MaxScore:    header.MaxScore,
				Status:      "Passed",
				Description: "X-Content-Type-Options is properly configured to prevent MIME-sniffing attacks.",
				Recommendation: fmt.Sprintf(`PASSED: X-Content-Type-Options is properly configured.

Current value: %s

This header prevents browsers from MIME-sniffing responses away from the declared content-type.

Your configuration is secure. No action required.`, header.Value),
			})
		}
	}

	// Check for Referrer-Policy (always report)
	if header, ok := sh.Headers["Referrer-Policy"]; ok {
		if !header.Present {
			vulns = append(vulns, Vulnerability{
				Name:        "Referrer-Policy",
				Category:    "Miscellaneous Headers",
				Severity:    "Medium",
				Score:       0,
				MaxScore:    10,
				Status:      "Failed",
				Description: "Referrer-Policy controls how much referrer information (sent via the Referer header) should be included with requests. Without this header, sensitive information in URLs may be leaked to third parties.",
				Recommendation: `MEDIUM: Referrer-Policy header missing. Sensitive URL information may be leaked to third parties.

Recommended Headers:

Referrer-Policy: strict-origin-when-cross-origin

Or for maximum privacy:

Referrer-Policy: no-referrer

Options explained:
• no-referrer: Never send referrer information
• strict-origin-when-cross-origin: Send full URL for same-origin, only origin for cross-origin
• same-origin: Only send referrer for same-origin requests

Implementation:
• Apache: Header always set Referrer-Policy "strict-origin-when-cross-origin"
• Nginx: add_header Referrer-Policy "strict-origin-when-cross-origin" always;
• Express.js: app.use(helmet.referrerPolicy({ policy: 'strict-origin-when-cross-origin' }))`,
				CVSS: &CVSSScore{
					BaseScore: 3.7,
					Severity:  "LOW",
					Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N",
					Version:   "3.1",
				},
			})
		} else {
			// Referrer-Policy properly configured
			vulns = append(vulns, Vulnerability{
				Name:        "Referrer-Policy",
				Category:    "Miscellaneous Headers",
				Severity:    "Info",
				Score:       header.Score,
				MaxScore:    header.MaxScore,
				Status:      "Passed",
				Description: "Referrer-Policy is properly configured to control referrer information leakage.",
				Recommendation: fmt.Sprintf(`PASSED: Referrer-Policy is properly configured.

Current value: %s

This header controls how much referrer information is sent with requests, protecting sensitive URL data.

Your configuration is secure. No action required.`, header.Value),
			})
		}
	}

	// Check for Permissions-Policy (always report)
	if header, ok := sh.Headers["Permissions-Policy"]; ok {
		if !header.Present {
			vulns = append(vulns, Vulnerability{
				Name:        "Permissions-Policy",
				Category:    "Miscellaneous Headers",
				Severity:    "Medium",
				Score:       0,
				MaxScore:    10,
				Status:      "Failed",
				Description: "Permissions-Policy (formerly Feature-Policy) allows you to control which browser features and APIs can be used in the browser, preventing misuse of powerful features like geolocation, camera, microphone, etc.",
				Recommendation: `MEDIUM: Permissions-Policy header missing. Browser features are not restricted.

Recommended Header:

Permissions-Policy: geolocation=(), microphone=(), camera=(), payment=(), usb=(), magnetometer=(), gyroscope=(), accelerometer=()

This disables potentially dangerous browser features. Adjust based on your needs.

Implementation:
• Apache: Header always set Permissions-Policy "geolocation=(), microphone=(), camera=()"
• Nginx: add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
• Express.js: app.use(helmet.permissionsPolicy())`,
				CVSS: &CVSSScore{
					BaseScore: 4.3,
					Severity:  "MEDIUM",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N",
					Version:   "3.1",
				},
			})
		} else {
			// Permissions-Policy properly configured
			vulns = append(vulns, Vulnerability{
				Name:        "Permissions-Policy",
				Category:    "Miscellaneous Headers",
				Severity:    "Info",
				Score:       header.Score,
				MaxScore:    header.MaxScore,
				Status:      "Passed",
				Description: "Permissions-Policy is properly configured to restrict browser features.",
				Recommendation: fmt.Sprintf(`PASSED: Permissions-Policy is properly configured.

Current value: %s

This header controls which browser features and APIs can be used, preventing misuse of powerful capabilities.

Your configuration is secure. No action required.`, header.Value),
			})
		}
	}

	// Check for HSTS with issues (present but not perfect)
	if header, ok := sh.Headers["Strict-Transport-Security"]; ok && header.Present && len(header.Issues) > 0 {
		vulns = append(vulns, Vulnerability{
			Name:        "HSTS Configuration Issue",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "Low",
			Score:       header.Score,
			MaxScore:    header.MaxScore,
			Status:      "Warning",
			Description: "HTTP Strict Transport Security (HSTS) is present but has configuration issues that reduce its effectiveness.",
			Recommendation: fmt.Sprintf(`LOW: HSTS header has configuration issues.

Current value: %s

Issues found:
%s

Recommended Header:

Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

The 'preload' directive allows your site to be included in browsers' HSTS preload list for maximum protection.`,
				header.Value,
				strings.Join(header.Issues, "\n")),
			CVSS: &CVSSScore{
				BaseScore: 3.7,
				Severity:  "LOW",
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N",
				Version:   "3.1",
			},
		})
	}

	// Check for Cross-Origin-Embedder-Policy (always report)
	if header, ok := sh.Headers["Cross-Origin-Embedder-Policy"]; ok {
		if !header.Present {
			vulns = append(vulns, Vulnerability{
				Name:        "Cross-Origin-Embedder-Policy (COEP)",
				Category:    "Cross-Origin Resource Sharing (CORS)",
				Severity:    "Medium",
				Score:       0,
				MaxScore:    5,
				Status:      "Failed",
				Description: "Cross-Origin-Embedder-Policy (COEP) prevents a document from loading any cross-origin resources that don't explicitly grant permission. This helps protect against side-channel attacks like Spectre.",
				Recommendation: `MEDIUM: Cross-Origin-Embedder-Policy header missing.

Recommended Header:

Cross-Origin-Embedder-Policy: require-corp

This ensures that all resources loaded by the document have opted in to being loaded cross-origin.

Implementation:
• Apache: Header always set Cross-Origin-Embedder-Policy "require-corp"
• Nginx: add_header Cross-Origin-Embedder-Policy "require-corp" always;
• Express.js: app.use((req, res, next) => { res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp'); next(); })

Note: This may require updating CORS headers on your resources.`,
				CVSS: &CVSSScore{
					BaseScore: 4.3,
					Severity:  "MEDIUM",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N",
					Version:   "3.1",
				},
			})
		} else {
			// COEP properly configured
			vulns = append(vulns, Vulnerability{
				Name:        "Cross-Origin-Embedder-Policy (COEP)",
				Category:    "Cross-Origin Resource Sharing (CORS)",
				Severity:    "Info",
				Score:       header.Score,
				MaxScore:    header.MaxScore,
				Status:      "Passed",
				Description: "Cross-Origin-Embedder-Policy is properly configured to protect against side-channel attacks.",
				Recommendation: fmt.Sprintf(`PASSED: Cross-Origin-Embedder-Policy is properly configured.

Current value: %s

This header ensures that all resources loaded have opted in to being loaded cross-origin, protecting against side-channel attacks like Spectre.

Your configuration is secure. No action required.`, header.Value),
			})
		}
	}

	// Check for Cross-Origin-Opener-Policy (always report)
	if header, ok := sh.Headers["Cross-Origin-Opener-Policy"]; ok {
		if !header.Present {
			vulns = append(vulns, Vulnerability{
				Name:        "Cross-Origin-Opener-Policy (COOP)",
				Category:    "Cross-Origin Resource Sharing (CORS)",
				Severity:    "Medium",
				Score:       0,
				MaxScore:    5,
				Status:      "Failed",
				Description: "Cross-Origin-Opener-Policy (COOP) allows you to ensure that a top-level document does not share a browsing context group with cross-origin documents. This helps protect against cross-origin attacks like XS-Leaks.",
				Recommendation: `MEDIUM: Cross-Origin-Opener-Policy header missing.

Recommended Header:

Cross-Origin-Opener-Policy: same-origin

This isolates your browsing context to prevent cross-origin attacks.

Options:
• same-origin: Isolates the browsing context exclusively to same-origin documents
• same-origin-allow-popups: Allows the document to retain references to popups
• unsafe-none: Default, allows sharing browsing context (not recommended)

Implementation:
• Apache: Header always set Cross-Origin-Opener-Policy "same-origin"
• Nginx: add_header Cross-Origin-Opener-Policy "same-origin" always;
• Express.js: app.use((req, res, next) => { res.setHeader('Cross-Origin-Opener-Policy', 'same-origin'); next(); })`,
				CVSS: &CVSSScore{
					BaseScore: 4.3,
					Severity:  "MEDIUM",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N",
					Version:   "3.1",
				},
			})
		} else {
			// COOP properly configured
			vulns = append(vulns, Vulnerability{
				Name:        "Cross-Origin-Opener-Policy (COOP)",
				Category:    "Cross-Origin Resource Sharing (CORS)",
				Severity:    "Info",
				Score:       header.Score,
				MaxScore:    header.MaxScore,
				Status:      "Passed",
				Description: "Cross-Origin-Opener-Policy is properly configured to isolate browsing contexts.",
				Recommendation: fmt.Sprintf(`PASSED: Cross-Origin-Opener-Policy is properly configured.

Current value: %s

This header ensures your top-level document doesn't share browsing contexts with cross-origin documents, protecting against XS-Leaks attacks.

Your configuration is secure. No action required.`, header.Value),
			})
		}
	}

	// Check for Content-Type header (always report)
	if header, ok := sh.Headers["Content-Type"]; ok {
		if !header.Present {
			vulns = append(vulns, Vulnerability{
				Name:        "Content-Type Header",
				Category:    "Miscellaneous Headers",
				Severity:    "Medium",
				Score:       0,
				MaxScore:    5,
				Status:      "Failed",
				Description: "The Content-Type header specifies the media type of the resource and helps prevent MIME-type confusion attacks.",
				Recommendation: `MEDIUM: Content-Type header missing.

Recommended Header:

Content-Type: text/html; charset=utf-8

Always specify the Content-Type header with the appropriate charset to prevent encoding-based attacks.

Implementation:
• Apache: AddDefaultCharset UTF-8
• Nginx: charset utf-8;
• Express.js: res.type('html').charset = 'utf-8'
• PHP: header('Content-Type: text/html; charset=utf-8');`,
			})
		} else {
			vulns = append(vulns, Vulnerability{
				Name:        "Content-Type Header",
				Category:    "Miscellaneous Headers",
				Severity:    "Info",
				Score:       header.Score,
				MaxScore:    header.MaxScore,
				Status:      "Passed",
				Description: "Content-Type header is properly configured.",
				Recommendation: fmt.Sprintf(`PASSED: Content-Type header is properly configured.

Current value: %s

Your configuration is secure. No action required.`, header.Value),
			})
		}
	}

	// Check for deprecated X-XSS-Protection header
	if len(sh.Warnings) > 0 {
		for _, warning := range sh.Warnings {
			if strings.Contains(warning, "X-XSS-Protection") {
				vulns = append(vulns, Vulnerability{
					Name:        "Deprecated X-XSS-Protection Header",
					Category:    "Miscellaneous Headers",
					Severity:    "Low",
					Score:       0,
					MaxScore:    5,
					Status:      "Warning",
					Description: "The X-XSS-Protection header is deprecated and can introduce security vulnerabilities. Modern browsers use CSP instead.",
					Recommendation: `LOW: ` + warning + `

The X-XSS-Protection header is deprecated and may introduce vulnerabilities in older browsers.

Recommended Action:
1. Set X-XSS-Protection: 0 (to disable the feature)
2. Or remove the header entirely
3. Use Content-Security-Policy instead for XSS protection

Implementation:
• Apache: Header always set X-XSS-Protection "0"
• Nginx: add_header X-XSS-Protection "0" always;
• Express.js: app.use(helmet({ xssFilter: false }))`,
				})
			}
		}
	}

	// Check for server header exposure in warnings
	if len(sh.Warnings) > 0 {
		for _, warning := range sh.Warnings {
			if strings.Contains(warning, "Server header exposes") {
				vulns = append(vulns, Vulnerability{
					Name:        "Server Information Disclosure",
					Category:    "Miscellaneous Headers",
					Severity:    "Low",
					Score:       0,
					MaxScore:    5,
					Status:      "Warning",
					Description: "The Server header exposes information about your web server software and version. This information can help attackers identify known vulnerabilities in specific server versions and target attacks more effectively.",
					Recommendation: `LOW: Server header exposes server software information.

Current issue: ` + warning + `

Recommended Actions:

1. Remove the Server header entirely (most secure)
2. Or obfuscate it to a generic value

Implementation:
• Nginx: Add to nginx.conf:
  server_tokens off;
  more_clear_headers 'Server';

• Apache: Add to httpd.conf:
  ServerTokens Prod
  ServerSignature Off
  Header unset Server

• Express.js:
  app.disable('x-powered-by');
  app.use((req, res, next) => { res.removeHeader('Server'); next(); })

Removing server information makes it harder for attackers to identify your stack and find specific exploits.`,
					CVSS: &CVSSScore{
						BaseScore: 2.0,
						Severity:  "LOW",
						Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
						Version:   "3.1",
					},
				})
			}
		}
	}

	// Add passed checks (properly configured headers)
	if header, ok := sh.Headers["X-Frame-Options"]; ok && header.Present {
		vulns = append(vulns, Vulnerability{
			Name:        "X-Frame-Options",
			Category:    "Clickjacking Protection",
			Severity:    "Info",
			Score:       header.Score,
			MaxScore:    header.MaxScore,
			Status:      "Passed",
			Description: "X-Frame-Options is properly configured to prevent clickjacking attacks.",
			Recommendation: fmt.Sprintf(`PASSED: X-Frame-Options is properly configured.

Current value: %s

This header prevents your website from being embedded in frames or iframes, protecting against clickjacking attacks.

Your configuration is secure. No action required.`, header.Value),
		})
	}

	if header, ok := sh.Headers["Strict-Transport-Security"]; ok && header.Present && len(header.Issues) == 0 {
		vulns = append(vulns, Vulnerability{
			Name:        "HTTP Strict Transport Security (HSTS)",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "Info",
			Score:       header.Score,
			MaxScore:    header.MaxScore,
			Status:      "Passed",
			Description: "HSTS is properly configured to enforce HTTPS connections.",
			Recommendation: fmt.Sprintf(`PASSED: HSTS is properly configured.

Current value: %s

This header forces browsers to only connect via HTTPS, preventing man-in-the-middle attacks.

Your configuration is secure. No action required.`, header.Value),
		})
	}

	return vulns
}

// analyzeTLSCompliance converts TLS findings into vulnerabilities
func analyzeTLSCompliance(tls *TLSComplianceResult, target string) []Vulnerability {
	vulns := []Vulnerability{}

	// Critical issues
	for _, issue := range tls.Issues {
		severity := "Medium"
		cvssScore := 5.3
		if issue.Severity == "critical" {
			severity = "Critical"
			cvssScore = 9.1
		} else if issue.Severity == "high" {
			severity = "High"
			cvssScore = 7.4
		}

		vulns = append(vulns, Vulnerability{
			Name:           issue.Standard + ": " + issue.Requirement,
			Category:       "Transport Layer Security (TLS)",
			Severity:       severity,
			Score:          0,
			MaxScore:       20,
			Status:         "Failed",
			Description:    issue.Description,
			Recommendation: issue.Remediation,
			CVSS: &CVSSScore{
				BaseScore: cvssScore,
				Severity:  strings.ToUpper(severity),
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
		})
	}

	// Recommendations (not critical but good practice)
	for _, rec := range tls.Recommendations {
		if strings.Contains(rec, "TLS 1.3") {
			vulns = append(vulns, Vulnerability{
				Name:        "TLS Version Recommendation",
				Category:    "Transport Layer Security (TLS)",
				Severity:    "Info",
				Score:       0,
				MaxScore:    5,
				Status:      "Info",
				Description: "Your site is using TLS 1.2, which is secure but not the latest version. TLS 1.3 offers improved security and performance benefits.",
				Recommendation: fmt.Sprintf(`INFO: %s

TLS 1.3 Benefits:
• Improved security with removed outdated cipher suites
• Faster handshake (1-RTT instead of 2-RTT)
• Better privacy (encrypted handshake)
• Mandatory forward secrecy

Implementation:
• Nginx: ssl_protocols TLSv1.2 TLSv1.3;
• Apache: SSLProtocol -all +TLSv1.2 +TLSv1.3
• Most modern servers support TLS 1.3 by default

Note: Ensure client compatibility before disabling TLS 1.2`, rec),
			})
		}

		if strings.Contains(rec, "Certificate expires") {
			vulns = append(vulns, Vulnerability{
				Name:        "TLS Certificate Expiring Soon",
				Category:    "Transport Layer Security (TLS)",
				Severity:    "Medium",
				Score:       0,
				MaxScore:    5,
				Status:      "Warning",
				Description: "Your TLS certificate is approaching expiration. Expired certificates cause browser warnings and connection failures, disrupting service availability.",
				Recommendation: fmt.Sprintf(`MEDIUM: %s

Actions Required:

1. Renew your certificate before expiration
2. Set up automated renewal (e.g., with certbot for Let's Encrypt)
3. Monitor certificate expiration dates

For Let's Encrypt certificates:
• Use certbot with auto-renewal: certbot renew --dry-run
• Set up cron job: 0 0 * * * certbot renew --quiet

For other CAs:
• Check your certificate management dashboard
• Set up renewal reminders
• Consider automated certificate management tools`, rec),
				CVSS: &CVSSScore{
					BaseScore: 5.3,
					Severity:  "MEDIUM",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
					Version:   "3.1",
				},
			})
		}
	}

	// Add passed checks for TLS components when compliant
	if tls.Compliant {
		// TLS Version check passed
		vulns = append(vulns, Vulnerability{
			Name:        "TLS Version",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Passed",
			Description: fmt.Sprintf("TLS version is properly configured. Using: %s", tls.TLSVersion),
			Recommendation: fmt.Sprintf(`PASSED: TLS version is secure.

Current version: %s

Your TLS configuration meets security standards.

Your configuration is secure. No action required.`, tls.TLSVersion),
		})

		// Cipher Suite check passed
		vulns = append(vulns, Vulnerability{
			Name:        "Cipher Suite",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Passed",
			Description: fmt.Sprintf("Strong cipher suite is being used: %s", tls.CipherSuite),
			Recommendation: fmt.Sprintf(`PASSED: Cipher suite is secure.

Current cipher: %s

Strong cipher suites provide:
• Forward secrecy
• Authenticated encryption
• Protection against known attacks

Your configuration is secure. No action required.`, tls.CipherSuite),
		})

		// Check if certificate info is available and valid
		if tls.CertificateInfo != nil {
			// Certificate Hostname & Chain
			vulns = append(vulns, Vulnerability{
				Name:        "Certificate Hostname & Chain",
				Category:    "Transport Layer Security (TLS)",
				Severity:    "Info",
				Score:       20,
				MaxScore:    20,
				Status:      "Passed",
				Description: "TLS certificate hostname and chain are valid.",
				Recommendation: fmt.Sprintf(`PASSED: Certificate hostname and chain are valid.

Certificate Details:
• Issuer: %s
• Subject: %s
• Valid Until: %s

Your certificate configuration is secure. No action required.`,
					tls.CertificateInfo.Issuer,
					tls.CertificateInfo.Subject,
					tls.CertificateInfo.NotAfter),
			})

			// Certificate Expiry
			vulns = append(vulns, Vulnerability{
				Name:        "Certificate Expiry",
				Category:    "Transport Layer Security (TLS)",
				Severity:    "Info",
				Score:       20,
				MaxScore:    20,
				Status:      "Passed",
				Description: "Certificate expiry is valid and not approaching expiration.",
				Recommendation: fmt.Sprintf(`PASSED: Certificate has sufficient validity period.

Valid Until: %s
Days Remaining: %d

Best Practices:
• Monitor certificate expiration dates
• Set up automated renewal
• Maintain at least 30 days buffer before expiration

Your configuration is secure. No action required.`,
					tls.CertificateInfo.NotAfter,
					tls.CertificateInfo.DaysUntilExpiry),
			})
		}

		// HTTPS Enabled (if we got TLS info, HTTPS is enabled)
		vulns = append(vulns, Vulnerability{
			Name:        "HTTPS Enabled",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Passed",
			Description: "HTTPS is properly enabled and configured.",
			Recommendation: `PASSED: HTTPS is enabled.

HTTPS provides:
• Encryption of data in transit
• Authentication of the server
• Data integrity protection
• Required for modern web features

Your configuration is secure. No action required.`,
		})

		// Deprecated TLS versions not supported
		vulns = append(vulns, Vulnerability{
			Name:        "Deprecated TLS Versions",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Passed",
			Description: "No deprecated TLS versions (SSL 3.0, TLS 1.0, TLS 1.1) are supported.",
			Recommendation: `PASSED: No deprecated TLS versions detected.

Deprecated versions blocked:
• SSL 3.0 (POODLE attack)
• TLS 1.0 (various weaknesses)
• TLS 1.1 (outdated cryptography)

Supported secure versions:
• TLS 1.2 (widely compatible, secure)
• TLS 1.3 (modern, recommended)

Your configuration is secure. No action required.`,
		})

		// Mixed Content check passed (if HTTPS is working properly)
		vulns = append(vulns, Vulnerability{
			Name:        "Mixed Content",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Passed",
			Description: "No mixed content issues detected. All resources are loaded over HTTPS.",
			Recommendation: `PASSED: No mixed content detected.

Mixed content occurs when an HTTPS page loads resources (images, scripts, stylesheets) over HTTP, which undermines security.

Best Practices:
• Always use HTTPS URLs for all resources
• Use protocol-relative URLs (//example.com/script.js)
• Use Content-Security-Policy to block mixed content
• Regularly audit external resource URLs

Your configuration is secure. No action required.`,
		})

		// OCSP Stapling (add as info if not critical)
		vulns = append(vulns, Vulnerability{
			Name:        "OCSP Stapling",
			Category:    "Transport Layer Security (TLS)",
			Severity:    "Info",
			Score:       5,
			MaxScore:    5,
			Status:      "Info",
			Description: "OCSP Stapling is a performance optimization for certificate validation.",
			Recommendation: `INFO: Consider enabling OCSP Stapling.

OCSP Stapling benefits:
• Improved TLS handshake performance
• Better privacy (client doesn't contact OCSP server)
• Reduced load on CA infrastructure

Implementation:
• Nginx: ssl_stapling on; ssl_stapling_verify on;
• Apache: SSLUseStapling on

Note: This is optional and provides performance benefits rather than security improvements.`,
		})
	}

	return vulns
}

// analyzeCookieFindings converts cookie findings into vulnerabilities
func analyzeCookieFindings(cookies []CookieFinding, target string) []Vulnerability {
	vulns := []Vulnerability{}

	hasInsecureCookies := false
	for _, cookie := range cookies {
		if cookie.MissingSecure || cookie.MissingHTTPOnly {
			hasInsecureCookies = true
			break
		}
	}

	if hasInsecureCookies {
		vulns = append(vulns, Vulnerability{
			Name:        "Insecure Cookie Configuration",
			Category:    "Cookie Security",
			Severity:    "Medium",
			Score:       0,
			MaxScore:    15,
			Status:      "Failed",
			Description: "Cookies are missing Secure and/or HttpOnly flags. Cookies without the Secure flag can be transmitted over unencrypted HTTP connections, allowing attackers to intercept them. Cookies without HttpOnly can be accessed by JavaScript, making them vulnerable to XSS attacks and session hijacking.",
			Recommendation: `MEDIUM: Insecure cookie configuration detected.

Required Flags:
• Secure flag: Ensures cookies are only sent over HTTPS
• HttpOnly flag: Prevents JavaScript access to cookies

Implementation:
• PHP: session_set_cookie_params(['secure' => true, 'httponly' => true, 'samesite' => 'Strict']);
• Express.js: res.cookie('name', 'value', { secure: true, httpOnly: true, sameSite: 'strict' });
• Java: cookie.setSecure(true); cookie.setHttpOnly(true);

All session cookies should have both Secure and HttpOnly flags set.`,
			CVSS: &CVSSScore{
				BaseScore: 5.9,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
				Version:   "3.1",
			},
		})
	} else if len(cookies) > 0 {
		// Cookies are properly configured
		vulns = append(vulns, Vulnerability{
			Name:        "Set-Cookie Headers (Secure/HttpOnly)",
			Category:    "Cookie Security",
			Severity:    "Info",
			Score:       15,
			MaxScore:    15,
			Status:      "Passed",
			Description: "All cookies have Secure and HttpOnly flags properly configured.",
			Recommendation: `PASSED: Cookie security flags are properly set.

Your cookies include:
• Secure flag: Cookies only sent over HTTPS
• HttpOnly flag: Cookies protected from JavaScript access

Best Practices:
• Always set Secure flag for all cookies
• Use HttpOnly for session cookies
• Consider SameSite attribute for CSRF protection
• Minimize cookie lifespan

Your configuration is secure. No action required.`,
		})
	}

	return vulns
}

// analyzeCORSIssues converts CORS findings into vulnerabilities
func analyzeCORSIssues(cors *CORSReport, target string) []Vulnerability {
	vulns := []Vulnerability{}

	if cors.AllowsAnyOrigin && cors.AllowCredentials {
		vulns = append(vulns, Vulnerability{
			Name:        "Overly Permissive CORS Policy",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "High",
			Score:       0,
			MaxScore:    20,
			Status:      "Failed",
			Description: "The CORS policy allows any origin (*) with credentials enabled. This is a dangerous configuration that allows any website to make authenticated requests to your API, potentially exposing sensitive user data and enabling cross-site request forgery attacks.",
			Recommendation: `HIGH: Dangerous CORS configuration detected.

Issues:
• Access-Control-Allow-Origin: * with credentials enabled
• This allows any website to access your API with user credentials

Fix:
1. Never use Access-Control-Allow-Origin: * with credentials
2. Specify exact allowed origins: Access-Control-Allow-Origin: https://trusted-domain.com
3. Validate and whitelist origins on the server side
4. Only enable credentials when absolutely necessary

Example (Express.js):
const allowedOrigins = ['https://trusted-domain.com'];
app.use(cors({
  origin: function (origin, callback) {
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));`,
			CVSS: &CVSSScore{
				BaseScore: 8.1,
				Severity:  "HIGH",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
		})
	}

	for _, issue := range cors.Issues {
		if cors.AllowsAnyOrigin && cors.AllowCredentials &&
			(strings.Contains(issue, "credentials") || strings.Contains(issue, "allows any origin")) {
			continue
		}
		vulns = append(vulns, Vulnerability{
			Name:        "CORS Misconfiguration",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    corsIssueSeverity(issue),
			Score:       0,
			MaxScore:    10,
			Status:      "Warning",
			Description: issue,
			Recommendation: `Review your Access-Control-* and related headers to ensure only required origins, headers, and responses are permitted.

Key actions:
1. Avoid using '*' for sensitive headers (Allow-Headers / Expose-Headers)
2. Provide a reasonable Access-Control-Max-Age for preflight caching
3. Include Cross-Origin-Resource-Policy for resource isolation
4. Add 'Vary: Origin' when returning per-origin responses`,
		})
	}

	// Add individual CORS header checks (always report)

	// 1. Access-Control-Allow-Origin
	if cors.MissingAllowOrigin {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Allow-Origin Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "High",
			Score:       0,
			MaxScore:    15,
			Status:      "Failed",
			Description: "The Access-Control-Allow-Origin header is missing. This header is required for cross-origin requests.",
			Recommendation: `HIGH: Access-Control-Allow-Origin header is missing.

This header specifies which origins can access your resources.

Recommended Configuration:
• For specific origin: Access-Control-Allow-Origin: https://trusted-domain.com
• For multiple origins: Implement server-side origin validation
• NEVER use '*' with credentials

Implementation:
• Nginx: add_header Access-Control-Allow-Origin "https://trusted-domain.com" always;
• Apache: Header set Access-Control-Allow-Origin "https://trusted-domain.com"
• Express.js: res.header('Access-Control-Allow-Origin', 'https://trusted-domain.com');`,
		})
	} else if cors.AllowOrigin != "" {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Allow-Origin Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       15,
			MaxScore:    15,
			Status:      "Passed",
			Description: fmt.Sprintf("Access-Control-Allow-Origin header is properly configured: %s", cors.AllowOrigin),
			Recommendation: fmt.Sprintf(`PASSED: Access-Control-Allow-Origin header is configured.

Current value: %s

Your configuration is secure. No action required.`, cors.AllowOrigin),
		})
	}

	// 2. Access-Control-Allow-Credentials
	if cors.AllowCredentials {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Allow-Credentials Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       10,
			MaxScore:    10,
			Status:      "Passed",
			Description: "Access-Control-Allow-Credentials is enabled. This allows cross-origin requests to include credentials.",
			Recommendation: `PASSED: Access-Control-Allow-Credentials is configured.

Current value: true

This header allows cookies and authentication to be sent with cross-origin requests.

Security Note:
• Never use with Access-Control-Allow-Origin: *
• Only enable for trusted origins
• Validate the origin on the server side

Your configuration includes credentials support. Ensure it's only used with trusted origins.`,
		})
	} else {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Allow-Credentials Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       10,
			MaxScore:    10,
			Status:      "Info",
			Description: "Access-Control-Allow-Credentials is not enabled. Cross-origin requests will not include credentials.",
			Recommendation: `INFO: Access-Control-Allow-Credentials is not set.

Credentials (cookies, HTTP authentication) are not allowed in cross-origin requests.

This is the secure default. Only enable if you need to support authenticated cross-origin requests.`,
		})
	}

	// 3. Access-Control-Allow-Headers
	if cors.AllowHeaders != "" {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Allow-Headers Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       10,
			MaxScore:    10,
			Status:      "Passed",
			Description: fmt.Sprintf("Access-Control-Allow-Headers is configured: %s", cors.AllowHeaders),
			Recommendation: fmt.Sprintf(`PASSED: Access-Control-Allow-Headers is configured.

Current value: %s

This header specifies which headers can be used in the actual request.

Your configuration is active.`, cors.AllowHeaders),
		})
	} else {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Allow-Headers Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       10,
			MaxScore:    10,
			Status:      "Info",
			Description: "Access-Control-Allow-Headers is not set. Only simple headers are allowed.",
			Recommendation: `INFO: Access-Control-Allow-Headers not configured.

Only simple headers (Accept, Accept-Language, Content-Language, Content-Type with limited values) are allowed.

Set this header if you need to accept custom headers in cross-origin requests.`,
		})
	}

	// 4. Access-Control-Expose-Headers
	if cors.ExposeHeaders != "" {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Expose-Headers Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       5,
			MaxScore:    5,
			Status:      "Passed",
			Description: fmt.Sprintf("Access-Control-Expose-Headers is configured: %s", cors.ExposeHeaders),
			Recommendation: fmt.Sprintf(`PASSED: Access-Control-Expose-Headers is configured.

Current value: %s

This header specifies which response headers can be exposed to the client.

Your configuration is active.`, cors.ExposeHeaders),
		})
	} else {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Expose-Headers Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       5,
			MaxScore:    5,
			Status:      "Info",
			Description: "Access-Control-Expose-Headers is not set. Only simple response headers are exposed.",
			Recommendation: `INFO: Access-Control-Expose-Headers not configured.

Only simple response headers (Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma) are exposed to JavaScript.

Set this header if you need to expose custom response headers to the client.`,
		})
	}

	// 5. Access-Control-Max-Age
	if cors.MaxAge != "" {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Max-Age Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       5,
			MaxScore:    5,
			Status:      "Passed",
			Description: fmt.Sprintf("Access-Control-Max-Age is configured: %s seconds", cors.MaxAge),
			Recommendation: fmt.Sprintf(`PASSED: Access-Control-Max-Age is configured.

Current value: %s seconds

This header specifies how long preflight request results can be cached.

Your configuration is active.`, cors.MaxAge),
		})
	} else {
		vulns = append(vulns, Vulnerability{
			Name:        "Access-Control-Max-Age Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       5,
			MaxScore:    5,
			Status:      "Info",
			Description: "Access-Control-Max-Age is not set. Preflight results are not cached.",
			Recommendation: `INFO: Access-Control-Max-Age not configured.

Consider setting this header to reduce preflight requests and improve performance.

Recommended value: Access-Control-Max-Age: 86400 (24 hours)`,
		})
	}

	// 6. Cross-Origin-Resource-Policy
	if cors.ResourcePolicy != "" {
		vulns = append(vulns, Vulnerability{
			Name:        "Cross-Origin-Resource-Policy Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       5,
			MaxScore:    5,
			Status:      "Passed",
			Description: fmt.Sprintf("Cross-Origin-Resource-Policy is configured: %s", cors.ResourcePolicy),
			Recommendation: fmt.Sprintf(`PASSED: Cross-Origin-Resource-Policy is configured.

Current value: %s

This header protects against side-channel attacks by controlling which origins can include this resource.

Your configuration is active.`, cors.ResourcePolicy),
		})
	} else {
		vulns = append(vulns, Vulnerability{
			Name:        "Cross-Origin-Resource-Policy Header",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Medium",
			Score:       0,
			MaxScore:    5,
			Status:      "Failed",
			Description: "Cross-Origin-Resource-Policy is not set. Resources can be included by any origin.",
			Recommendation: `MEDIUM: Cross-Origin-Resource-Policy header missing.

Recommended values:
• same-origin: Only same-origin documents can include this resource
• same-site: Same-site documents can include this resource
• cross-origin: Any origin can include this resource (least secure)

Implementation:
• Nginx: add_header Cross-Origin-Resource-Policy "same-origin" always;
• Apache: Header set Cross-Origin-Resource-Policy "same-origin"
• Express.js: res.header('Cross-Origin-Resource-Policy', 'same-origin');`,
		})
	}

	// 7. Vary: Origin
	if cors.VaryOrigin {
		vulns = append(vulns, Vulnerability{
			Name:        "Vary: Origin Header (CORS Caching)",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Info",
			Score:       5,
			MaxScore:    5,
			Status:      "Passed",
			Description: "Vary: Origin header is set. This ensures proper caching of CORS responses.",
			Recommendation: `PASSED: Vary: Origin header is configured.

This header tells caches that the response varies based on the Origin header, ensuring correct CORS caching behavior.

Your configuration is secure. No action required.`,
		})
	} else {
		vulns = append(vulns, Vulnerability{
			Name:        "Vary: Origin Header (CORS Caching)",
			Category:    "Cross-Origin Resource Sharing (CORS)",
			Severity:    "Low",
			Score:       0,
			MaxScore:    5,
			Status:      "Failed",
			Description: "Vary: Origin header is missing. This may cause incorrect caching of CORS responses.",
			Recommendation: `LOW: Vary: Origin header missing.

When using dynamic CORS (different Access-Control-Allow-Origin based on request origin), you should include:

Vary: Origin

This ensures caches treat responses differently based on the Origin header.

Implementation:
• Nginx: add_header Vary "Origin" always;
• Apache: Header set Vary "Origin"
• Express.js: res.vary('Origin');`,
		})
	}

	// 8. Cross-Origin Resource Isolation (CORI) - inferred from COEP + COOP presence
	// Note: This is a conceptual check based on having both COEP and COOP configured
	vulns = append(vulns, Vulnerability{
		Name:        "Cross-Origin Resource Isolation",
		Category:    "Cross-Origin Resource Sharing (CORS)",
		Severity:    "Info",
		Score:       5,
		MaxScore:    5,
		Status:      "Info",
		Description: "Cross-Origin Resource Isolation (CORI) is achieved through proper configuration of COEP and COOP headers.",
		Recommendation: `INFO: Cross-Origin Resource Isolation

CORI is not a single header but a security model achieved by:
• Cross-Origin-Embedder-Policy (COEP): require-corp
• Cross-Origin-Opener-Policy (COOP): same-origin

When both are set, your site achieves cross-origin isolation, enabling powerful features like SharedArrayBuffer.

Check the individual COEP and COOP checks for your configuration status.`,
	})

	return vulns
}

func corsIssueSeverity(issue string) string {
	lower := strings.ToLower(issue)
	switch {
	case strings.Contains(lower, "missing allow-origin"):
		return "High"
	case strings.Contains(lower, "allows any header"), strings.Contains(lower, "exposes all headers"):
		return "Medium"
	case strings.Contains(lower, "cross-origin-resource-policy"):
		return "Medium"
	default:
		return "Low"
	}
}

// analyzeCachePolicy converts cache policy findings into vulnerabilities
func analyzeCachePolicy(cache *CachePolicy, target string) []Vulnerability {
	vulns := []Vulnerability{}

	for _, issue := range cache.Issues {
		if strings.Contains(issue, "Expires header missing") {
			vulns = append(vulns, Vulnerability{
				Name:        "Missing Cache Expires Header",
				Category:    "Cache Configuration",
				Severity:    "Low",
				Score:       0,
				MaxScore:    5,
				Status:      "Info",
				Description: "The Expires header is missing. While Cache-Control is present, having both headers provides better compatibility with older browsers and proxies.",
				Recommendation: fmt.Sprintf(`LOW: %s

Current cache configuration:
Cache-Control: %s

Recommendation:

Add an Expires header for better compatibility:
Expires: <HTTP-date>

Example Configuration:

For static assets (1 year):
• Nginx:
  expires 1y;
  add_header Cache-Control "public, immutable";

• Apache:
  ExpiresActive On
  ExpiresDefault "access plus 1 year"

For dynamic content (no cache):
• Nginx:
  expires -1;
  add_header Cache-Control "no-cache, no-store, must-revalidate";

• Apache:
  ExpiresActive On
  ExpiresDefault "access plus 0 seconds"

Note: Modern browsers primarily use Cache-Control, but Expires provides backward compatibility.`,
					issue, cache.CacheControl),
				CVSS: &CVSSScore{
					BaseScore: 0.0,
					Severity:  "NONE",
					Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N",
					Version:   "3.1",
				},
			})
		}
	}

	return vulns
}

// analyzeClientSecurity converts client-side security findings into vulnerabilities
func analyzeClientSecurity(cs *ClientSecurityResult, target string) []Vulnerability {
	vulns := []Vulnerability{}

	// Analyze vulnerable JavaScript libraries
	for _, lib := range cs.VulnerableLibraries {
		severity := "Medium"
		cvssScore := 5.3

		switch lib.Severity {
		case "critical":
			severity = "Critical"
			cvssScore = lib.CVSS
		case "high":
			severity = "High"
			cvssScore = lib.CVSS
		case "medium":
			severity = "Medium"
			cvssScore = lib.CVSS
		}

		vulnName := fmt.Sprintf("Vulnerable %s Library", lib.Name)

		vulns = append(vulns, Vulnerability{
			Name:     vulnName,
			Category: "Client-Side Security",
			Severity: severity,
			Score:    0,
			MaxScore: 20,
			Status:   "Failed",
			Description: fmt.Sprintf("The website is using %s version %s, which has known security vulnerabilities. %s",
				lib.Name, lib.DetectedVersion, lib.Description),
			Recommendation: fmt.Sprintf(`%s: %s

Vulnerability Details:
• Library: %s
• Detected Version: %s
• CVE IDs: %s
• CVSS Score: %.1f

%s

Update Priority: %s
Risk: Attackers can exploit known vulnerabilities in outdated JavaScript libraries to compromise your application and users' data.`,
				strings.ToUpper(severity),
				vulnName,
				lib.Name,
				lib.DetectedVersion,
				strings.Join(lib.VulnerabilityIDs, ", "),
				lib.CVSS,
				lib.Recommendation,
				strings.ToUpper(severity)),
			CVSS: &CVSSScore{
				BaseScore: cvssScore,
				Severity:  strings.ToUpper(severity),
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N",
				Version:   "3.1",
			},
			References: lib.VulnerabilityIDs,
		})
	}

	// Add "No Vulnerable JS Libraries" check when none are found
	if len(cs.VulnerableLibraries) == 0 {
		vulns = append(vulns, Vulnerability{
			Name:        "Vulnerable JS Libraries",
			Category:    "Client-Side Security (Miscellaneous)",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Passed",
			Description: "No vulnerable JavaScript libraries were detected on this website.",
			Recommendation: `PASSED: No vulnerable JavaScript libraries detected.

Your website does not use any JavaScript libraries with known security vulnerabilities.

Best Practices:
• Regularly update all JavaScript libraries and frameworks
• Use tools like npm audit, yarn audit, or Snyk for dependency scanning
• Subscribe to security advisories for libraries you use
• Consider using a Software Composition Analysis (SCA) tool
• Implement a regular update schedule for dependencies

Your configuration is secure. No action required.`,
		})
	}

	// Analyze CSRF protection
	if cs.CSRFProtection != nil && !cs.CSRFProtection.HasCSRFToken {
		vulns = append(vulns, Vulnerability{
			Name:        "No CSRF Protection",
			Category:    "Client-Side Security",
			Severity:    "High",
			Score:       0,
			MaxScore:    20,
			Status:      "Failed",
			Description: "The application does not implement Cross-Site Request Forgery (CSRF) protection. This allows attackers to trick authenticated users into performing unwanted actions on your application.",
			Recommendation: `HIGH: No CSRF protection detected.

CSRF (Cross-Site Request Forgery) allows attackers to trick authenticated users into executing malicious actions without their knowledge.

Immediate Actions Required:

1. Implement CSRF tokens for all state-changing requests
2. Use the Synchronizer Token Pattern or Double-Submit Cookie
3. Set SameSite cookie attributes to Strict or Lax
4. Validate Origin and Referer headers

Implementation by Framework:

• Express.js:
  const csrf = require('csurf');
  app.use(csrf({ cookie: true }));

• Django:
  {% csrf_token %} in all forms
  Middleware: 'django.middleware.csrf.CsrfViewMiddleware'

• Rails:
  protect_from_forgery with: :exception
  <%= csrf_meta_tags %> in layout

• Laravel:
  @csrf in all forms
  VerifyCsrfToken middleware enabled

Cookie Configuration:
Set-Cookie: session=...; SameSite=Strict; Secure; HttpOnly

Testing:
1. Try submitting a form from a different origin
2. Verify CSRF tokens are validated
3. Check SameSite cookie attributes`,
			CVSS: &CVSSScore{
				BaseScore: 8.1,
				Severity:  "HIGH",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
			References: []string{
				"https://owasp.org/www-community/attacks/csrf",
				"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html",
			},
		})
	} else if cs.CSRFProtection != nil && cs.CSRFProtection.Protection == "weak" {
		vulns = append(vulns, Vulnerability{
			Name:           "Weak CSRF Protection",
			Category:       "Client-Side Security",
			Severity:       "Medium",
			Score:          5,
			MaxScore:       20,
			Status:         "Warning",
			Description:    fmt.Sprintf("CSRF protection is present but weak. %s", strings.Join(cs.CSRFProtection.Issues, "; ")),
			Recommendation: cs.CSRFProtection.Recommendation,
			CVSS: &CVSSScore{
				BaseScore: 6.5,
				Severity:  "MEDIUM",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
				Version:   "3.1",
			},
		})
	} else if cs.CSRFProtection != nil && cs.CSRFProtection.Protection == "moderate" {
		vulns = append(vulns, Vulnerability{
			Name:           "CSRF Protection Could Be Improved",
			Category:       "Client-Side Security",
			Severity:       "Low",
			Score:          10,
			MaxScore:       20,
			Status:         "Warning",
			Description:    "CSRF protection is present but could be strengthened with additional measures.",
			Recommendation: cs.CSRFProtection.Recommendation,
		})
	}

	// Check for Trusted Types
	if !cs.TrustedTypes {
		vulns = append(vulns, Vulnerability{
			Name:        "Trusted Types Not Implemented",
			Category:    "Client-Side Security",
			Severity:    "Low",
			Score:       0,
			MaxScore:    10,
			Status:      "Info",
			Description: "Trusted Types is a modern browser security feature that helps prevent DOM-based XSS attacks by ensuring that only trusted values can be assigned to dangerous sink functions.",
			Recommendation: `INFO: Consider implementing Trusted Types for DOM XSS prevention.

Trusted Types is a defense-in-depth mechanism that helps prevent DOM-based XSS attacks.

How it works:
• Ensures only trusted values can be used in dangerous DOM APIs
• Prevents common XSS patterns like element.innerHTML = userInput
• Requires explicit sanitization of user input

Implementation:

Add to Content-Security-Policy header:
Content-Security-Policy: require-trusted-types-for 'script'; trusted-types default

Or start with report-only mode:
Content-Security-Policy-Report-Only: require-trusted-types-for 'script'

Code Example:
// Create a policy
const escapePolicy = trustedTypes.createPolicy('escape', {
  createHTML: (string) => string.replace(/</g, '&lt;')
});

// Use the policy
element.innerHTML = escapePolicy.createHTML(userInput);

Browser Support:
• Chrome/Edge 83+
• Not yet supported in Firefox/Safari (graceful fallback)

References:
• https://web.dev/trusted-types/
• https://developer.mozilla.org/en-US/docs/Web/API/Trusted_Types_API`,
			CVSS: &CVSSScore{
				BaseScore: 0.0,
				Severity:  "INFO",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N",
				Version:   "3.1",
			},
			References: []string{
				"https://web.dev/trusted-types/",
				"https://developer.mozilla.org/en-US/docs/Web/API/Trusted_Types_API",
			},
		})
	}

	return vulns
}

// analyzeNetworkSecurity converts network security findings into vulnerabilities
func analyzeNetworkSecurity(ns *NetworkSecurityResult, target string) []Vulnerability {
	vulns := []Vulnerability{}

	// Analyze open ports
	criticalPorts := []PortInfo{}
	highRiskPorts := []PortInfo{}

	for _, port := range ns.OpenPorts {
		switch port.Risk {
		case "critical":
			criticalPorts = append(criticalPorts, port)
		case "high":
			highRiskPorts = append(highRiskPorts, port)
		}
	}

	// Critical ports vulnerability
	if len(criticalPorts) > 0 {
		portList := []string{}
		for _, port := range criticalPorts {
			portList = append(portList, fmt.Sprintf("%d (%s)", port.Port, port.Service))
		}

		vulns = append(vulns, Vulnerability{
			Name:     "Critical Ports Exposed",
			Category: "Network Security",
			Severity: "Critical",
			Score:    0,
			MaxScore: 20,
			Status:   "Failed",
			Description: fmt.Sprintf("Critical network ports are exposed to the internet. These ports should never be publicly accessible: %s",
				strings.Join(portList, ", ")),
			Recommendation: fmt.Sprintf(`CRITICAL: Exposed critical ports detected.

Exposed Ports: %s

These ports are commonly targeted by attackers and should be protected:

Immediate Actions:

1. Close or firewall these ports immediately
2. Use VPN for remote access instead of direct exposure
3. Implement network segmentation
4. Enable IP whitelisting if remote access is required

Port-Specific Recommendations:

• Port 23 (Telnet): Replace with SSH (port 22) with key-based auth
• Port 3389 (RDP): Use VPN or SSH tunneling, enable NLA, use strong passwords
• Port 5900 (VNC): Use SSH tunneling, never expose directly
• Database ports: Never expose to internet, use private networks

Defense Measures:
• Configure firewall rules to block external access
• Use cloud security groups / network ACLs
• Implement fail2ban for brute-force protection
• Enable audit logging for all access attempts

Verification:
Run: nmap -p %s %s
Ensure ports show as "filtered" or "closed" from external networks`,
				strings.Join(portList, ", "),
				strings.Join(portList, ","),
				target),
			CVSS: &CVSSScore{
				BaseScore: 9.8,
				Severity:  "CRITICAL",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
				Version:   "3.1",
			},
			References: []string{
				"https://www.cisa.gov/uscert/ncas/tips/ST04-015",
				"https://owasp.org/www-project-web-security-testing-guide/",
			},
		})
	}

	// High risk ports
	if len(highRiskPorts) > 0 {
		portList := []string{}
		for _, port := range highRiskPorts {
			portList = append(portList, fmt.Sprintf("%d (%s)", port.Port, port.Service))
		}

		vulns = append(vulns, Vulnerability{
			Name:     "High-Risk Ports Exposed",
			Category: "Network Security",
			Severity: "High",
			Score:    0,
			MaxScore: 15,
			Status:   "Warning",
			Description: fmt.Sprintf("High-risk network ports are exposed: %s. These ports require proper authentication and encryption.",
				strings.Join(portList, ", ")),
			Recommendation: fmt.Sprintf(`HIGH: High-risk ports exposed to the internet.

Exposed Ports: %s

Required Security Measures:

1. Ensure strong authentication is enabled
2. Use encrypted protocols (TLS/SSL)
3. Implement rate limiting and brute-force protection
4. Keep software up to date
5. Monitor access logs

Port-Specific Recommendations:

• Port 22 (SSH):
  - Use key-based authentication, disable password auth
  - Change default port
  - Use fail2ban or similar
  - Keep SSH updated

• Port 3306 (MySQL):
  - Bind to localhost only if possible
  - Use strong passwords and limit user privileges
  - Enable SSL/TLS connections
  - Regular security updates

• Port 5432 (PostgreSQL):
  - Configure pg_hba.conf properly
  - Use SSL connections
  - Limit network access
  - Regular updates

• Port 6379 (Redis):
  - Enable authentication (requirepass)
  - Bind to localhost or private IP
  - Use TLS (redis 6.0+)
  - Disable dangerous commands

Best Practices:
• Use VPN or SSH tunneling for database access
• Implement network segmentation
• Use cloud security groups to restrict access
• Enable audit logging`,
				strings.Join(portList, ", ")),
			CVSS: &CVSSScore{
				BaseScore: 7.5,
				Severity:  "HIGH",
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
				Version:   "3.1",
			},
		})
	}

	// Always report on Open Ports check (passed if no critical/high-risk ports found)
	if len(criticalPorts) == 0 && len(highRiskPorts) == 0 {
		vulns = append(vulns, Vulnerability{
			Name:        "Open Ports",
			Category:    "Network Security",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Passed",
			Description: "No critical or high-risk network ports are exposed to the internet.",
			Recommendation: `PASSED: No high-risk ports are publicly exposed.

Your network configuration is secure with no dangerous ports detected.

Common ports that should remain closed:
• Port 23 (Telnet) - Unencrypted remote access
• Port 3389 (RDP) - Windows Remote Desktop
• Port 5900 (VNC) - Remote desktop sharing
• Database ports (3306 MySQL, 5432 PostgreSQL, 6379 Redis, 27017 MongoDB)

Best Practices:
• Use firewalls to control port access
• Regularly scan for open ports
• Close unnecessary services
• Use VPN for remote access

Your configuration is secure. No action required.`,
		})
	}

	// Subdomain takeover vulnerability
	if ns.SubdomainTakeover != nil && ns.SubdomainTakeover.Vulnerable {
		confidenceLevel := ns.SubdomainTakeover.Confidence
		severity := "High"
		cvssScore := 7.5

		if confidenceLevel == "high" {
			severity = "Critical"
			cvssScore = 9.1
		}

		vulns = append(vulns, Vulnerability{
			Name:     "Subdomain Takeover Vulnerability",
			Category: "Network Security",
			Severity: severity,
			Score:    0,
			MaxScore: 20,
			Status:   "Failed",
			Description: fmt.Sprintf("The subdomain '%s' is vulnerable to takeover. It has a CNAME record pointing to '%s' (%s), but the service is not claimed or configured. Attackers could claim this service and host malicious content on your subdomain.",
				target, ns.SubdomainTakeover.CNAME, ns.SubdomainTakeover.Provider),
			Recommendation: fmt.Sprintf(`%s: Subdomain takeover vulnerability detected!

Vulnerability Details:
• Subdomain: %s
• CNAME Target: %s
• Provider: %s
• Confidence: %s
• Fingerprint: %s

IMMEDIATE ACTION REQUIRED:

Option 1: Claim the Service (Recommended if needed)
1. Log in to %s
2. Claim/configure the service for: %s
3. Verify the subdomain loads correctly
4. Monitor for any unauthorized changes

Option 2: Remove the DNS Record (If service not needed)
1. Access your DNS management console
2. Delete the CNAME record for this subdomain
3. Verify removal with: dig %s CNAME
4. Monitor for 24-48 hours

Option 3: Reconfigure (If migrating)
1. Set up the new service endpoint
2. Update the CNAME record
3. Verify functionality
4. Remove old CNAME

Why This Is Critical:
• Attackers can host phishing sites on your domain
• Can serve malware using your trusted domain
• Damages brand reputation and user trust
• Can bypass email and security filters
• May be used for session hijacking

Verification Steps:
1. Check DNS: dig %s CNAME
2. Visit the subdomain in browser
3. Check for 404 errors or unclaimed service messages
4. Monitor for unexpected content

Prevention:
• Regularly audit DNS records
• Remove unused subdomains
• Use monitoring services for subdomain takeovers
• Implement DNS CAA records
• Use infrastructure-as-code for DNS management`,
				strings.ToUpper(severity),
				target,
				ns.SubdomainTakeover.CNAME,
				ns.SubdomainTakeover.Provider,
				ns.SubdomainTakeover.Confidence,
				ns.SubdomainTakeover.Fingerprint,
				ns.SubdomainTakeover.Provider,
				ns.SubdomainTakeover.CNAME,
				target,
				target),
			CVSS: &CVSSScore{
				BaseScore: cvssScore,
				Severity:  strings.ToUpper(severity),
				Vector:    "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
				Version:   "3.1",
			},
			References: []string{
				"https://owasp.org/www-community/attacks/Subdomain_Takeover",
				"https://developer.mozilla.org/en-US/docs/Web/Security/Subdomain_takeovers",
				ns.SubdomainTakeover.Recommendation,
			},
		})
	} else if ns.SubdomainTakeover != nil && !ns.SubdomainTakeover.Vulnerable {
		// Subdomain takeover check passed
		vulns = append(vulns, Vulnerability{
			Name:        "Subdomain Takeover",
			Category:    "Network Security",
			Severity:    "Info",
			Score:       20,
			MaxScore:    20,
			Status:      "Passed",
			Description: "The subdomain is not vulnerable to takeover attacks. All DNS records are properly configured and claimed.",
			Recommendation: `PASSED: No subdomain takeover vulnerability detected.

Your DNS configuration is secure. All CNAME records point to valid, claimed services.

What is Subdomain Takeover?
A subdomain takeover occurs when a subdomain points to an external service (via CNAME) that is no longer active or claimed. Attackers can claim that service and host malicious content on your subdomain.

Prevention Best Practices:
• Regularly audit DNS records
• Remove unused subdomains and CNAME records
• Monitor for unclaimed services
• Use DNS monitoring tools
• Implement DNS CAA records
• Document all subdomains and their purposes

Your configuration is secure. No action required.`,
		})
	}

	return vulns
}
