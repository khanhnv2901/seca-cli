package checker

import (
	"strings"
	"testing"
	"time"
)

func TestBuildVulnerabilityReport(t *testing.T) {
	startTime := time.Now().Format(time.RFC3339)
	endTime := time.Now().Add(5 * time.Second).Format(time.RFC3339)

	results := []CheckResult{
		{
			Target: "https://example.com",
			SecurityHeaders: &SecurityHeadersResult{
				Score:    33,
				Grade:    "F",
				MaxScore: 100,
				Headers: map[string]HeaderStatus{
					"Content-Security-Policy": {
						Present:        false,
						Severity:       "high",
						Score:          0,
						MaxScore:       20,
						Recommendation: "Implement CSP",
					},
					"X-Frame-Options": {
						Present:        true,
						Value:          "DENY",
						Severity:       "high",
						Score:          15,
						MaxScore:       15,
						Recommendation: "Properly configured",
					},
				},
				Missing: []string{"Content-Security-Policy"},
			},
			TLSCompliance: &TLSComplianceResult{
				Compliant:       true,
				TLSVersion:      "TLS 1.2",
				CipherSuite:     "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
				Recommendations: []string{"Consider upgrading to TLS 1.3"},
			},
			CookieFindings: []CookieFinding{
				{
					Name:            "session",
					MissingSecure:   true,
					MissingHTTPOnly: false,
				},
			},
			CORSInsights: &CORSReport{
				AllowsAnyOrigin:  false,
				AllowCredentials: false,
				Issues:           []string{"Access-Control-Allow-Origin header missing"},
			},
			CachePolicy: &CachePolicy{
				CacheControl: "no-cache",
				Issues:       []string{"Expires header missing"},
			},
		},
	}

	report := BuildVulnerabilityReport(results, "https://example.com", startTime, endTime)

	if report == nil {
		t.Fatal("expected non-nil report")
	}

	if report.ScanURL != "https://example.com" {
		t.Errorf("expected scan URL https://example.com, got %s", report.ScanURL)
	}

	if report.TotalURLsScanned != 1 {
		t.Errorf("expected 1 URL scanned, got %d", report.TotalURLsScanned)
	}

	if report.Status != "Completed" {
		t.Errorf("expected status Completed, got %s", report.Status)
	}

	if len(report.Vulnerabilities) == 0 {
		t.Error("expected vulnerabilities to be found")
	}

	// Check that vulnerabilities are sorted by severity
	for i := 0; i < len(report.Vulnerabilities)-1; i++ {
		curr := severityToInt(report.Vulnerabilities[i].Severity)
		next := severityToInt(report.Vulnerabilities[i+1].Severity)
		if curr < next {
			t.Errorf("vulnerabilities not sorted correctly: %s before %s",
				report.Vulnerabilities[i].Severity, report.Vulnerabilities[i+1].Severity)
		}
	}

	// Verify summary counts
	if report.Summary.Total != len(report.Vulnerabilities) {
		t.Errorf("summary total %d doesn't match vulnerability count %d",
			report.Summary.Total, len(report.Vulnerabilities))
	}
}

func severityToInt(severity string) int {
	switch severity {
	case "Critical":
		return 5
	case "High":
		return 4
	case "Medium":
		return 3
	case "Low":
		return 2
	case "Info":
		return 1
	default:
		return 0
	}
}

func TestSortVulnerabilitiesBySeverity(t *testing.T) {
	vulns := []Vulnerability{
		{Name: "Low1", Severity: "Low"},
		{Name: "Critical1", Severity: "Critical"},
		{Name: "Medium1", Severity: "Medium"},
		{Name: "High1", Severity: "High"},
		{Name: "Info1", Severity: "Info"},
	}

	sortVulnerabilitiesBySeverity(vulns)

	expected := []string{"Critical", "High", "Medium", "Low", "Info"}
	for i, vuln := range vulns {
		if vuln.Severity != expected[i] {
			t.Errorf("position %d: expected %s, got %s", i, expected[i], vuln.Severity)
		}
	}
}

func TestAnalyzeSecurityHeaders(t *testing.T) {
	headers := &SecurityHeadersResult{
		Score:    50,
		Grade:    "D",
		MaxScore: 100,
		Headers: map[string]HeaderStatus{
			"Content-Security-Policy": {
				Present:        false,
				Severity:       "high",
				Score:          0,
				MaxScore:       20,
				Recommendation: "Implement CSP",
			},
			"X-Frame-Options": {
				Present:        true,
				Value:          "DENY",
				Severity:       "high",
				Score:          15,
				MaxScore:       15,
				Recommendation: "Properly configured",
			},
		},
		Missing:  []string{"Content-Security-Policy"},
		Warnings: []string{"Server header exposes version"},
	}

	vulns := analyzeSecurityHeaders(headers, "https://example.com")

	if len(vulns) == 0 {
		t.Fatal("expected vulnerabilities from header analysis")
	}

	// Should find security header findings (CSP or Clickjacking or XSS protection)
	foundHeader := false
	for _, v := range vulns {
		if strings.Contains(v.Category, "CSP") ||
		   strings.Contains(v.Category, "Clickjacking") ||
		   strings.Contains(v.Category, "XSS") ||
		   strings.Contains(v.Category, "Headers") {
			foundHeader = true
			break
		}
	}
	if !foundHeader {
		t.Error("expected to find security header vulnerabilities")
	}
}

func TestAnalyzeTLSCompliance(t *testing.T) {
	tls := &TLSComplianceResult{
		Compliant:   false,
		TLSVersion:  "TLS 1.0",
		CipherSuite: "TLS_RSA_WITH_RC4_128_SHA",
		Recommendations: []string{
			"Upgrade to TLS 1.3",
			"Certificate expires in 10 days",
		},
		CertificateInfo: &CertificateInfo{
			Subject:         "CN=example.com",
			DaysUntilExpiry: 10,
			SelfSigned:      false,
			ValidChain:      true,
			SignatureAlg:    "SHA256-RSA",
		},
	}

	vulns := analyzeTLSCompliance(tls, "https://example.com")

	if len(vulns) == 0 {
		t.Fatal("expected TLS vulnerabilities")
	}

	// Should generate TLS-related vulnerabilities
	foundTLS := false
	for _, v := range vulns {
		if v.Category == "Transport Layer Security (TLS)" {
			foundTLS = true
			break
		}
	}
	if !foundTLS {
		t.Error("expected to find TLS-related vulnerabilities")
	}
}

func TestAnalyzeTLSComplianceWithIssues(t *testing.T) {
	tests := []struct {
		name             string
		issues           []ComplianceIssue
		expectedSeverity string
		expectedCVSS     float64
	}{
		{
			name: "critical issue",
			issues: []ComplianceIssue{
				{
					Standard:    "OWASP ASVS 9.1.3",
					Requirement: "TLS Version",
					Severity:    "critical",
					Description: "Using deprecated TLS 1.0",
					Remediation: "Upgrade to TLS 1.2+",
				},
			},
			expectedSeverity: "Critical",
			expectedCVSS:     9.1,
		},
		{
			name: "high severity issue",
			issues: []ComplianceIssue{
				{
					Standard:    "PCI DSS 4.1",
					Requirement: "Cipher Suite",
					Severity:    "high",
					Description: "Weak cipher suite",
					Remediation: "Use strong ciphers",
				},
			},
			expectedSeverity: "High",
			expectedCVSS:     7.4,
		},
		{
			name: "medium severity issue",
			issues: []ComplianceIssue{
				{
					Standard:    "NIST SP 800-52r2",
					Requirement: "Certificate",
					Severity:    "medium",
					Description: "Certificate issue",
					Remediation: "Fix certificate",
				},
			},
			expectedSeverity: "Medium",
			expectedCVSS:     5.3,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tls := &TLSComplianceResult{
				Compliant: false,
				Issues:    tt.issues,
			}

			vulns := analyzeTLSCompliance(tls, "https://example.com")

			if len(vulns) == 0 {
				t.Fatal("expected vulnerabilities")
			}

			found := false
			for _, v := range vulns {
				if v.Severity == tt.expectedSeverity {
					found = true
					if v.CVSS == nil {
						t.Error("expected CVSS score")
					} else if v.CVSS.BaseScore != tt.expectedCVSS {
						t.Errorf("expected CVSS %f, got %f", tt.expectedCVSS, v.CVSS.BaseScore)
					}
					if v.Status != "Failed" {
						t.Errorf("expected Failed status, got %s", v.Status)
					}
					break
				}
			}
			if !found {
				t.Errorf("expected to find %s severity vulnerability", tt.expectedSeverity)
			}
		})
	}
}

func TestAnalyzeTLSComplianceRecommendations(t *testing.T) {
	tests := []struct {
		name                   string
		recommendations        []string
		expectedVulnName       string
		expectedSeverity       string
		shouldFindRecommendation bool
	}{
		{
			name:                   "TLS 1.3 recommendation",
			recommendations:        []string{"Consider upgrading to TLS 1.3"},
			expectedVulnName:       "TLS Version Recommendation",
			expectedSeverity:       "Info",
			shouldFindRecommendation: true,
		},
		{
			name:                   "Certificate expiry",
			recommendations:        []string{"Certificate expires in 15 days"},
			expectedVulnName:       "TLS Certificate Expiring Soon",
			expectedSeverity:       "Medium",
			shouldFindRecommendation: true,
		},
		{
			name:                   "Multiple recommendations",
			recommendations:        []string{"Consider upgrading to TLS 1.3", "Certificate expires in 5 days"},
			expectedVulnName:       "",
			expectedSeverity:       "",
			shouldFindRecommendation: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tls := &TLSComplianceResult{
				Compliant:       true,
				Recommendations: tt.recommendations,
			}

			vulns := analyzeTLSCompliance(tls, "https://example.com")

			if !tt.shouldFindRecommendation {
				if len(vulns) > 0 {
					t.Error("expected no vulnerabilities")
				}
				return
			}

			if len(vulns) == 0 {
				t.Fatal("expected recommendation vulnerabilities")
			}

			if tt.expectedVulnName != "" {
				found := false
				for _, v := range vulns {
					if v.Name == tt.expectedVulnName {
						found = true
						if v.Severity != tt.expectedSeverity {
							t.Errorf("expected severity %s, got %s", tt.expectedSeverity, v.Severity)
						}
						if v.Category != "Transport Layer Security (TLS)" {
							t.Errorf("expected TLS category, got %s", v.Category)
						}
					}
				}
				if !found {
					t.Errorf("expected to find vulnerability named %s", tt.expectedVulnName)
				}
			}
		})
	}
}

func TestAnalyzeTLSComplianceEmpty(t *testing.T) {
	tls := &TLSComplianceResult{
		Compliant:       true,
		Issues:          []ComplianceIssue{},
		Recommendations: []string{},
	}

	vulns := analyzeTLSCompliance(tls, "https://example.com")

	if len(vulns) == 0 {
		t.Fatal("expected compliance details for TLS checks")
	}

	for _, v := range vulns {
		if v.Status == "Failed" {
			t.Fatalf("did not expect failed TLS findings for compliant scan, found %s", v.Name)
		}
	}
}

func TestAnalyzeCookieFindings(t *testing.T) {
	cookies := []CookieFinding{
		{
			Name:              "session_id",
			MissingSecure:     true,
			MissingHTTPOnly:   false,
			OriginalSetCookie: "session_id=abc123; Path=/",
		},
		{
			Name:              "auth_token",
			MissingSecure:     false,
			MissingHTTPOnly:   true,
			OriginalSetCookie: "auth_token=xyz789; Secure; Path=/",
		},
	}

	vulns := analyzeCookieFindings(cookies, "https://example.com")

	if len(vulns) == 0 {
		t.Fatal("expected cookie vulnerabilities")
	}

	// Should generate cookie-related findings
	foundCookie := false
	for _, v := range vulns {
		if v.Category == "Cookie Security" {
			foundCookie = true
			break
		}
	}

	if !foundCookie {
		t.Error("expected to find cookie security vulnerabilities")
	}
}

func TestAnalyzeCachePolicy(t *testing.T) {
	cache := &CachePolicy{
		CacheControl: "public, max-age=31536000",
		Expires:      "",
		Issues: []string{
			"Expires header missing",
			"Sensitive data may be cached",
		},
	}

	vulns := analyzeCachePolicy(cache, "https://example.com")

	if len(vulns) == 0 {
		t.Fatal("expected cache policy vulnerabilities")
	}

	// Check that issues are converted to vulnerabilities
	for _, v := range vulns {
		if !strings.Contains(v.Category, "Cache") {
			t.Errorf("expected Cache category, got %s", v.Category)
		}
	}
}

func TestCORSIssueSeverity(t *testing.T) {
	tests := []struct {
		issue    string
		expected string
	}{
		{"missing allow-origin", "High"},
		{"Cross-Origin-Resource-Policy header missing", "Medium"},
		{"allows any header with credentials", "Medium"},
		{"Unknown CORS issue", "Low"},
	}

	for _, tt := range tests {
		t.Run(tt.issue, func(t *testing.T) {
			severity := corsIssueSeverity(tt.issue)
			if severity != tt.expected {
				t.Errorf("expected %s, got %s", tt.expected, severity)
			}
		})
	}
}

func TestVulnerabilityReportSummary(t *testing.T) {
	vulns := []Vulnerability{
		{Severity: "Critical"},
		{Severity: "Critical"},
		{Severity: "High"},
		{Severity: "High"},
		{Severity: "High"},
		{Severity: "Medium"},
		{Severity: "Low"},
		{Severity: "Info"},
	}

	report := &VulnerabilityReport{
		Vulnerabilities: vulns,
	}

	// Count severities manually
	summary := VulnerabilitySummary{}
	for _, v := range vulns {
		summary.Total++
		switch v.Severity {
		case "Critical":
			summary.Critical++
		case "High":
			summary.High++
		case "Medium":
			summary.Medium++
		case "Low":
			summary.Low++
		case "Info":
			summary.Info++
		}
	}

	if summary.Critical != 2 {
		t.Errorf("expected 2 critical, got %d", summary.Critical)
	}
	if summary.High != 3 {
		t.Errorf("expected 3 high, got %d", summary.High)
	}
	if summary.Medium != 1 {
		t.Errorf("expected 1 medium, got %d", summary.Medium)
	}
	if summary.Low != 1 {
		t.Errorf("expected 1 low, got %d", summary.Low)
	}
	if summary.Info != 1 {
		t.Errorf("expected 1 info, got %d", summary.Info)
	}
	if summary.Total != 8 {
		t.Errorf("expected 8 total, got %d", summary.Total)
	}

	report.Summary = summary
}

func TestBuildVulnerabilityReportEmptyResults(t *testing.T) {
	report := BuildVulnerabilityReport([]CheckResult{}, "https://example.com", "2025-01-01", "2025-01-01")

	if report == nil {
		t.Fatal("expected non-nil report for empty results")
	}

	if report.TotalURLsScanned != 0 {
		t.Errorf("expected 0 URLs scanned, got %d", report.TotalURLsScanned)
	}

	if len(report.Vulnerabilities) != 0 {
		t.Errorf("expected 0 vulnerabilities, got %d", len(report.Vulnerabilities))
	}
}

func TestBuildVulnerabilityReportMultipleTargets(t *testing.T) {
	results := []CheckResult{
		{
			Target: "https://example.com",
			SecurityHeaders: &SecurityHeadersResult{
				Missing: []string{"Content-Security-Policy"},
				Headers: map[string]HeaderStatus{
					"Content-Security-Policy": {
						Present:  false,
						Severity: "high",
						MaxScore: 20,
					},
				},
			},
		},
		{
			Target: "https://example.com/login",
			SecurityHeaders: &SecurityHeadersResult{
				Missing: []string{"Content-Security-Policy"},
				Headers: map[string]HeaderStatus{
					"Content-Security-Policy": {
						Present:  false,
						Severity: "high",
						MaxScore: 20,
					},
				},
			},
		},
	}

	report := BuildVulnerabilityReport(results, "https://example.com", "2025-01-01", "2025-01-01")

	// Should aggregate same vulnerabilities across multiple URLs
	for _, v := range report.Vulnerabilities {
		if strings.Contains(v.Name, "Content-Security-Policy") {
			if len(v.AffectedURLs) != 2 {
				t.Errorf("expected CSP vulnerability to affect 2 URLs, got %d", len(v.AffectedURLs))
			}
		}
	}
}
